#!/usr/bin/env perl
# SPDX-License-Identifier: BSD-3-Clause
BEGIN { require 5.022 }
package Squashmount v22.0.0;

use strict;
use warnings;
use integer;
use feature 'state';

# use Getopt::Long 2.24 ();
use Cwd ();
use Exporter qw(import);
use Fcntl ();
use File::Compare ();
use File::Copy ();
use File::Find ();
use File::Path v2.6.5 ();
use File::Spec ();
use File::Temp 0.19 ();
# use File::Which ();  # not mandatory but recommended; there are fallbacks
# use IO::Uncompress::Gunzip ();  # if not available, flag ?/?? is ignored
# use Pod::Usage (); not mandatory, but no help/manpage without this
# use String::ShellQuote ();  # not mandatory but recommended: poor fallback
# use Term::ANSIColor ();  # not mandatory but recommended: fallback to no color

=encoding UTF-8

=head1 NAME

squashmount - mount certain directories with squashfs + overlay/aufs/...

=head1 SYNOPSIS

=over 8

=item B<squashmount> [options] I<command> [I<mask1> I<mask2> ...]

Where I<command> is one of B<mount>, B<umount>, B<remount>, B<set>, B<reset>,
B<status>, B<forget>, B<print->I<...>

=back

To see the full manual, type B<squashmount man>

=head1 DESCRIPTION

For each configured mount-point (resp. if I<mask1>, I<mask2>, ... are given,
for all mount-points whose tag matches at least one of the masks),
the corresponding directory is mounted readonly, using squash as a readonly
filesystem and additionally using overlay/aufs/... as a writable filesystem.

When the filesystem is umounted or remounted, the changed data is recompressed
(unless the mount-point is configured otherwise).

Normally, the init-system should call B<squashmount start> and
B<squashmount -f stop> on starting or shutdown of the system, respectively,
so that the data is regularly resquashed.
You can manually force this resquashing by calling B<squashmount remount>.

B<squashmount> reads its mount-points from F</etc/squashmount.pl> which is
documented later (the path can be changed with B<--config>, and there are
system fallbacks F</usr/lib/squashmount.pl> and F</lib/squashmount.pl> which
can be changed with B<--system-config>).
Configured directories are created if necessary; B<squashmount> never removes
directories (not even configured temporary directories).

B<squashmount> keeps its current state in F</run/squashmount> (the path
can be changed with B<--rundir>) in a format which may depend on tools used
and which may also change in future versions of B<squashmount>.
B<squashmount> assumes that its data stored
in F</run/squashmount> and the actually mounted directories coincide, that is,
that they are not mounted/umounted without using B<squashmount> and, in
particular, that you do not reboot without calling B<squashmount stop>
and without cleaning the directory.
Therefore, if you modify F</etc/squashmount.pl> (in some cases also if you
upgrade or downgrade B<squashmount>) you must make sure to update
F</run/squashmount>; see the documentation of the B<stop> and
B<forget> commands.

B<squashmount set> can be used to set/unset certain
temporary states for the matching mount-tags into F</run/squashmount> which
will be honored during umount, stop, restart, or remount.
For example, combining with B<--no-squash> or B<--kill> you can instruct
B<squashmount> to keep or kill the new data without resquashing when
umounting, remounting, or shutting down.
The set state is kept until B<squashmount stop> or B<squashmount restart> is
executed (or until F</run> is cleaned by the system e.g. on a reboot).
In particular, this state is unchanged by B<squashmount umount>,
B<squashmount mount>, or B<squashmount remount>.
To change the state permanently, modify the definition of the mount-tag in
the configuration file F</etc/squashmount.pl> correspondingly and call
B<squashmount reset> to propagate the modification to the running system.

Each I<command> applies to all configured mount-points
(resp. to those selected by the additional B<mask1> B<mask2> ... arguments).
The following values for I<command> are available:

=over 8

=item B<mount>

Mount all configured mount-points.

This works only if the corresponding squash-file already exists.
Use B<start> or B<create> instead if you want to create the squash-file
for the first time.

=item B<umount>

Umount all configured mount-points, resquashing if data was changed
(and has reached a configured threshold).
Moreover, the modified data in the CHANGES and WORKDIR directory is removed
(the directories are "cleaned").
This command keeps the local setting made with B<squashmount set>
unless the option B<-r> (B<--reset>) is used.

=item B<remount>

This is somewhat like calling B<umount> followed by B<mount>.
This is skipped if it is neither necessary to resquash nor to delete data
(when skipping, also the option B<-r> is ignored).
Use B<--force> to omit this skipping.

=item B<create>

This is meant to be used only the first time when a mount-point is used:
It creates the squash-file from the directory DIR specified in the
configuration of that mount-point; afterwards that directory is cleaned.
If the squash-file already exists, you have to use B<--force> (and B<--quiet>
if you want to suppress the corresponding warning).

=item B<start>

This is like B<squashmount mount> with two exception:

1. If there is not yet a squash-file (that is, presumably only the first time
when this mount-point is used), B<squashmount create> is executed in advance.

2. For those mount-points for which B<RESQUASH_ON_START> is true, an
analogue of the following sequence of commands is executed

B<squashmount mount>, B<squashmount remount>, B<squashmount -n set>,
that is, a (presumably postponed) resquash happens at B<squashmount start>
and will by default not happen on subsequent B<squashmount umount> or
B<squashmount stop> commands.

=item B<stop>

This is like calling B<squashmount umount> followed by B<squashmount forget>:
After umounting it forgets all corresponding information of B<squashmount set>
for the corresponding mount-points, and if the configuration uses
temporary directories, new directories will be chosen on the next B<mount>.
Moreover, previous directories are removed according to the setting of
B<RM_CHANGE>/B<$rm_change>, B<RM_WORKDIR>/B<$rm_workdir>,
B<RM_READONLY>/B<$rm_readonly>, B<RM_DIR>/B<$rm_dir>, and B<$rm_rundir>.

In order to change F</etc/squashmount.pl> after B<squashmount mount> was called,
the safe way is to call first B<squashmount stop> (at least for the
mount-points you want to modify) and then do your modifications.

If used with B<--force> also umounted mount-points are forgotten/dirs removed.

=item B<restart>

This is like calling B<squashmount stop> followed by B<squashmount start>.
Note that in contrast to B<remount> this is executed unconditionally
(and it differs also substantially from B<squashmount --force remount>).
If used with B<--force> forget and try to mount umounted mount-points.

=item B<status> or B<list>

This outputs some general status information, depending on the verbosity level.
To output particular data use the B<print-...> commands (and specify B<mask1>).

=item B<check>

Check whether B<DIR> is empty; usually this should always be the case.
Normally, this command requires that the corresponding mount-point is umounted.
Use option B<-f> to force an umount temporarily.
In this case, B<--lazy=0> and B<--lsof=1> are the defaults unless specified
by the option.

B<check> cannot be used if B<DIR> is unknown, that is, if B<DIR> is a defined
by a function which was never called before.
You can use B<squashmount -f print-dir> in advance to force B<DIR> to be known.

=item B<set>

If combined with other options, modify the corresponding active state
of B<--backup>, B<--tempdir>, B<--compression>, B<--threshold>, and B<--kill>
in F</run/squashmount>.

=item B<reset>

Undo all effects of a previous B<set> commands for the corresponding
mount-point, according to the current F</etc/squashmount.pl>.

If you change B<BACKUP>, B<TEMPDIR>, B<COMPRESSION>, B<THRESHOLD>, or B<KILL>
for a mount-point in </etc/squashmount.pl>, use B<squashmount reset> to
activate this new setting.
For other changes on F</etc/squashmount.pl> see the description of the
B<forget> command.

=item B<forget>

This removes B<all> local configuration stored in F</run/squashmount> for
the corresponding mount-points. It works only for umounted mount-points.
(You can use F<--force> to make it work anyway, but this is very dangerous;
see below).

In order to change F</etc/squashmount.pl> after B<squashmount mount> was called
(or when changing to a different version of F<squashmount>),
the safe way is to call first B<squashmount stop>, i.e. B<squashmount umount>
followed by B<squashmount forget> (at least for the mount-points you want to
modify) and only then do your modification/upgrade F<squashmount>.

If you shortcut this (e.g. because you forgot calling B<squashmount stop>
in advance or because you cannot umount currently some reason) you have to
know more details: Changes to B<BACKUP>, B<TEMPDIR>, B<COMPRESSION>,
B<THRESHOLD>, or B<KILL> can be made active by using B<squashmount reset>.
(In case of a change of the B<squashmount> version the behavior is not defined.)
With this knowledge you should be able to call B<squashmount stop> even
after you made your changes.

If you plan to use B<forget> with the B<--force> flag on a mounted mount-point,
you must know what you are doing: B<squashmount> is then no longer aware that
the corresponding mount-point is actually mounted; you are then responsible
for umounting these mount-points without using B<squashmount>.

=item B<print-tag>

Output the tag.
This is mainly useful to get a list of all tags if you do not specify a mask.
For usage in scripts, combine this with B<-q>.

=item B<print-dir>

Output the name of the directory B<DIR> of the specified mount-point(s).
For usage in scripts, combine this with B<-q>/B<-S> and pass a tag.

=item B<print-readonly>

Output the effective B<READONLY> directory.
Output B<1> if the mount-point is configured to be non-writable.
For usage in scripts, combine this with B<-q>/B<-S> and pass a tag.

=item B<print-changes>

Output the effective B<CHANGES> directory in which the modified data is stored.
The result is undefined if the mount-point is configured to be non-writable.
For usage in scripts, combine this with B<-q>/B<-S> and pass a tag.

=item B<print-workdir>

Output the effective B<WORKDIR> directory in which the modified data is stored.
The result is undefined if the mount-point is configured to be non-writable.
For usage in scripts, combine this with B<-q>/B<-S> and pass a tag.

=item B<print-file>

Output the absolute path to the squash-file.
For usage in scripts, combine this with B<-q>/B<-S> and pass a tag.

=item B<print-mtime>

Output the mtime of the squash-file.

=item B<print-type>

Output the tool actually used for mounting.
Possible output is C<overlay>, C<overlayfs>, C<overlayfs-obsolete>, C<aufs>,
C<fuse-overlayfs>, C<unionfs-fuse>, C<unionfs>, C<funionfs>, C<bind>,
C<readonly>, or the empty string (for not mounted or incompletely mounted;
you can check the details with B<print-squashtype>).
For usage in scripts, combine this with B<-q> and pass a tag.

=item B<print-squashtype>

Output the tool actually used for mounting the squash file.
Possible output is C<squashfs>, C<squashfuse>, C<unknown>, or the empty string.

=item B<print-new>

Output 1 if there is new (i.e. modified) data.
For usage in scripts, combine this with B<-q> and pass a tag.

=item B<print-will-squash>

Output 1 if data will be resquashed on the next umount/remount
according to current setting and data.
For usage in scripts, combine this with B<-q> and pass a tag.

=item B<print-threshold>

Output the currently active threshold value.
For usage in scripts, combine this with B<-q> and pass a tag.

=item B<print-kill>

Output 1, -1, or 0, depending on whether B<--kill> or B<--kill-or-resquash>
is active.
For usage in scripts, combine this with B<-q> and pass a tag.

=item B<help>

Print a brief help.

=item B<man>

Show the full manual.

=back

=head1 OPTIONS

=over 8

=item B<--help> or B<-h>

Display brief help.

=item B<--man> or B<-?>

Show the full manual.

=item B<--verbose> or B<-v> (accumulative)

Verbose output.
In verbose level 3 or larger any "external" command like B<mount> is output,
its output not being suppressed.
In verbose level 4 even additional options are passed to such external commands
to make them produce verbose output. This overrides also B<--mksquash-verbose>
partially, see the subsequent description.

=item B<--mksquash-verbose=>I<string>

Determines options and redirections for B<mksquashfs> relevant for verbosity.
It can be a combination of symbols, possibly followed by flags.
Later symbols/flags combinations override earlier ones.
Unknown symbols/flag combinations are tacitly ignored.
The following symbols do exist:

=over 16

=item B<i>:
Pass option B<-info> (automatic if verbose level is 4 or larger)

=item B<n>:
Pass option B<-no-progress>

=item B<p>:
Pass option B<-progress>

=item B<q>:
Pass option B<-quiet> (unless verbose level is 4 or larger)

=item B<r>:
Redirect stdout to F</dev/null> (unless verbose level is 3 or larger)

=item B<I>, B<N>, B<P>, B<Q>, B<R>
Ignore earlier respective symbol B<i>, B<n>, B<p>, B<q>, B<r>
if there was some. For instance, B<iqI>, B<qI>, or B<q> are all equivalent.
(These symbols are useful only when combined with flags.)

=back

The following flags do exist which can be appended to a symbol
to make the previous symbols act only conditionally.

For instance, B<mksquash> does not necessarily support B<-quiet>,
so you might want to use a flag to check whether this is the case.

Using flags makes the configuration more flexible, but costs running time,
of course, since the checks have to be executed.
However, B<squashmount> caches the results of checks, so that the checks
are made at most once per call of B<squashmount>.

=over 16

=item B<1>

Use the symbol only if B<stdout> B<is> a terminal.

=item B<->

Use the symbol only if B<stdout> is B<not> a terminal.

=item B<2>

Use the symbol only if B<stderr> B<is> a terminal.

=item B<+>

Use the symbol only if B<stderr> is B<not> a terminal.

=item B<?>

Use the symbol only if the output of B<mksquash> contains B<-quiet>.

=item B<!>

Use the symbol only if the output of B<mksquash> does B<not> contain B<-quiet>.

=back

The default I<string> is user-specified in F</etc/squashmount.pl>;
if not specified there, the default is B<q?n-n+!> which means that the
B<-quiet> option is used if it is supported, and B<-no-progress> is used
if either stdout is not a terminal or if stderr is not a terminal and
the B<-quiet> option is unknown (because there were patches for such
B<mksquashfs> versions which output the progress bar to stderr).

As an artificial complex example, B<q1q2r12Q!> would mean:
if stdout or stderr is a terminal, use B<-quiet>, and if stdout and
stdout are both terminals, redirect stdout to F</dev/null>; however,
do not use B<-quiet> if B<mksquash> does not know this option.

=item B<--quiet> or B<-q> (accumulative)

Quiet output.
Use this with B<check> or B<print-...> if you want to use the output in scripts.
See also B<--separator>.

=item B<--version> or B<-V>

Print version number and exit

=item B<--config=>I<file> or B<-c> I<file> (accumulative)

Using I<file> instead of B</etc/squashmount.pl> as a config file.
If this option is repeated, all passed B<file>s are parsed in the given order.

=item B<--system-config=>I<file> (accumulative)

If the file B</etc/squashmount.pl> cannot be read successfully
(or if none of the files specified by B<--config> can be read, respectively),
then the first successfully read file from the system config list
B</usr/lib/squashmount.pl> or B</lib/squashmount.pl> is used instead.
When this option is specified, that list is replaced by the filenames
specified by this option.
Note that in contrast to B<--config> only the first readable file is used,
and also this only if all of the regular configuration files fail.

=item B<--umount=>I<opt> or B<-u> I<opt> (accumulative)

Add option I<opt> to the default B<@umount> array (see also B<--umount-ro>).
If this option is repeated, all passed options are added to the array.
By default, this means that the option are used in the call to B<umount DIR>.
There might be code in B</etc/squashmount.pl> which treats this array value
differently (for examples, see the description of B<@umount> and B<UMOUNT>).

=item B<--umount-ro=>I<opt> or B<-U> I<opt> (accumulative)

Add option I<opt> to the default B<@umount_ro> array.
If this option is repeated, all passed options are added to the array.
By default, this means that the option are used in the call to B<umount>
when umounting a readonly directory.
There might be code in B</etc/squashmount.pl> which treats this array value
differently (for examples, see the description of B<@umount> and B<UMOUNT>).

=item B<--fumount=>I<opt> (accumulative)

Add option I<opt> to the default B<@fumount> array (see also B<--umount>).
If this option is repeated, all passed options are added to the array.
By default, this means that the option are used in the call to
B<fusermount -u DIR>.
There might be code in B</etc/squashmount.pl> which treats this array value
differently.

=item B<--fumount-ro=>I<opt> (accumulative)

Add option I<opt> to the default B<@fumount_ro> array (see also B<--umount-ro>).
If this option is repeated, all passed options are added to the array.
By default, this means that the option are used in the call to
B<fusermount -u DIR> when umounting a readonly directory.
There might be code in B</etc/squashmount.pl> which treats this array value
differently.

=item B<--user>

Set all options to support user mode mounting:

=over 16

=item Use B<$HOME/.squashmount.pl> instead of B</etc/squasmount.pl>

You can avoid/change this effect by specifying B<--config>

=item Use B<$TEMPDIR/squashmount$UID> instead of B</run/squashmount>

Here, B<$TEMPDIR> defaults to B</tmp>.
You can avoid/change the effect by specifying B<--rundir>.

=item Remove all C<-o allow_other> defaults

You can avoid this effect by specifying B<--allow>

=item Use default @order = qw(fuse-overlayfs!! unionfs-fuse!! funionfs!!)

You can avoid this effect by specifying B<--order>

=item Use default @squashorder = qw(squashfuse!!)

You can avoid this effect by specfiying B<--squashorder>

=back

=item B<--root=>I<dir> or B<-/> I<dir>

Since v18.0.0, the data stored in F</run/squashmount> contains information
(device and inode) about the root directory. If that root directory has changed
(e.g. because squashmount is called inside of a chroot), B<squashmount> will
refuse to handle the corresponding mount-point.
With this option, one can take action anyway.
There are two cases.

=over 16

=item I<dir> is empty.

In that case, B<squashmount> will tacitly ignore the difference of the
root directory information.
When writing to F</run/squashmount> it will use the previously stored
root directory information (if available) or not store this information,
respectively.
The latter means that the subsequent call of B<squashmount> will not check
that information.

=item I<dir> is a path

In that case, I<dir> must match the information about the root directory.
B<squashmount> will proceed as if I<dir> is the actual root directory
(and when writing to F</run/squashmount> will also store the information
of that directory).

=back

Very likely, one will supplement B<--root> with B<--bind>.

=item B<--bind=>I<from> I<to> or B<-2>I<from> I<to>

When binding directories (or within a chroot), it might happen that the paths
stored in F</run/squashmount> become wrong.
With this option, these paths get reinterpreted when reading from
F</run/squashmount> by replacing I<from> by I<to>; the paths get reinterpreted
when writing to F</run/squashmount> by replacing B<to> by B<from>.

Both, I<from> and I<to> are interpreted as absolute directory paths.

If this option is specified several times on the command line,
then for reading the order of reinterpretations is from left to right,
while for writing the order of reinterpretations is from right to left.

For instance, suppose that there are squashmount directories stored in

F</usr/A>

F</home/B>

and that within a chroot the same B</run/squashmount> and configuration
data is accessed, but the above directories are made visible as

F</bound/usr/A>

F</bound/new_home/B>

(for instance with B<mount --bind> with appropriate master/slave settings
or symlinks.)

In this case, B<-2 /usr /bound/usr> B<-2 /home /bound/new_home> will make the
B</run/squashmount> data valid from within the chroot (and will keep the
data valid from outside the chroot when writing).

Of course, in this example, one will also have to add a corresponding
B<--root> option (with a I<dir> argument if the original F</> is accessible
from inside the chroot under the directory I<dir>).

In this example, one could also have written
<-2 / /bound> <-2 /bound/home /bound/new_home>
because first replacing F</> by </bound> and then B</bound/home> by
B</bound/new_home> yields the same result.
Similarly, for the opposite replacement in the reverse order.
Hence, order of the B<--bind> arguments can be crucial.

=item B<--rundir=>I<dir>

Use I<dir> instead of F</run/squashmount>.

=item B<--interactive> or B<-i>

Ask for confirmation before cleaning a directory.

=item B<--order=>I<order> or B<-o> I<order>

Override the value of B<@order> from the configuration.
Any symbol which has no special meaning in I<order> can be used as a separator.
As a practical example, using B<--order=bind> with remount forces that the
corresponding mount-points are mounted readonly with --bind.

=item B<--squashorder=>I<squashorder> or B<-O> I<squashorder>

Override the value of B<@squashorder> from the configuration.
Any symbol which has no special meaning in I<squashorder>
can be used as a separator.

=item B<--no-squash> or B<--nosquash> or B<-n>

(This is an alias for B<--threshold=-1>.)
If used with B<umount> or B<remount> do not resquash the directories and
keep the new data.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--squash> or B<-s>

(This is an alias for B<--threshold=0> which is normally the default.)
If used with B<umount> or B<remount> squash the directories if they have
been changed. (See also B<--force-squash>.)

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--force-squash> or B<--squash-force>

(This is an alias for B<--threshold=-2>.)
If used with B<umount> or B<remount> squash the directories,
even if they have not been changed.

=item B<--threshold=>I<size> or B<-t> I<size>

For I<size>=B<-1> act as described for B<--no-squash>, and for I<size>=B<0>
act as described for B<--squash>, and for I<size>=B<-2> act as described
for B<--force-squash>.

For positive I<size>, if the length of the changes is less than I<size> bytes,
squashmount will act with B<umount> as if B<--no-squash> is active, otherwise
it acts normally, that is, the data is resquashed.

For convenience, you can append B<k>, B<m>, B<g>, B<t> to the number to denote
kilobytes (1024), megabytes (1024^2), gigabytes (1024^3),
or terabytes (1024^4), respectively.

For the particular case that I<size> is empty the value of the current
F</etc/squashmount.pl> is taken (cf. the B<unset> command).
This is useful if B<set> has been used:

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--kill> or B<-k>

When umounting/remounting do not resquash the data but delete all new data.
Use with care!
For safety reasons, this has no effect if the currently active B<--threshold>
value is negative.

If used with B<set>, set the B<KILL> state in F</run/squashmount> to B<1>,
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--kill-or-resquash> or B<-R>

When umounting/remounting a directory whose threshold is not reached,
remove all the data.
In other words: Only major changes are stored by resquashing;
all minor changes are lost.
Use with care!
For safety reasons, this has no effect if the currently active B<--threshold>
value is negative.

If used with B<set>, set the B<KILL> state in F</run/squashmount> to B<-1>,
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--no-kill> or B<--nokill> or B<-K>

Undo the effect of B<--kill>, B<--kill-or-resquash>, and of the B<KILL> key.

If used with B<set>, set the B<KILL> state in F</run/squashmount> to B<0>,
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--backup=>I<file/app> or B<-b> I<file/app>

Override the value of B<BACKUP> for all specified mount-points.
If nonempty and not an absolute path, the effective value is the current value
of B<FILE> with the string I<app> appended. The empty value means no backup.
For obvious reasons you should better not give an absolute path if
using several mount-points.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--no-backup> B<--nobackup> or B<-B>

This is equivalent to specifying B<--backup> with an empty argument:
For all specified mount-point no backup is made.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--tempdir=>I<tempdir> or B<-D> I<tempdir>

Override the value of B<TEMPDIR> for all specified mount-points.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--tar2sqfs> or B<--tar>

Use tar -> tar2sqfs from squashfs-tools-ng for compression instead of squashfs.

=item B<--no-tar2sqfs>, B<--notar2sqfs>, B<--no-tar>, or B<--notar>

This is the opposite of B<--tar>.
Whether B<--tar> or B<--no-tar> is the default depends on the
variable B<$tar2sqfs> in F</etc/squashmount.pl>.

=item B<--compression=>I<mode>, B<--comp=>I<mode>, or B<-x> I<mode>

Override the value of B<COMPRESSION> for all specified mount-points.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--reset> or B<-r>

After umounting, reset the data changed with the B<set> command according
to the current configuration in F</etc/squashmount.pl>

=item B<--force> or B<-f>

If used with B<remount> do not skip remounting, even if it is not
necessary to resquash or to delete data.

If used with B<create>, continue even if the squash-file already exists.

If used with B<check>, force temporary umounting.

If used with B<stop> or B<restart>, forget information also for
umounted mount-points.

If used with B<forget>, forget information also if mount-point is mounted.
The latter is very dangerous, see the description of the B<forget> command.

If used with B<print-...> or B<status>, when required to print directories
corresponding to temporary names not created yet, they will be created and
their names fixed for future mounting (until B<forgot> is used).

=item B<--ignore-state> or B<-I>

Whenever umounting, try to umount even mount-points which are apparently
umounted according to the setting in F</run/squashmount>.
If combined with B<-f> also try to umount B<READONLY> even if
umounting of B<DIR> failed.

Similarly, whenever mounting, try to mount even if apparently already
mounted according to the setting in F</run/squashmount>.
If combined with B<-f> proceed even if mounting of B<READONLY> seems to fail.

This option should only be necessary in exceptional cases like bugs in
B<squashmount> or F</etc/squashmount.pl> or if you manually interfered
or removed or corrupted F</run/squashmount>.
In this case, the best attempt is to call
C<squashmount -fI umount> or C<squashmount -nfI umount> for trying to force
umounting unconditionally all configured directories.

=item B<--lazy=>I<value> or B<-L> I<value>

If this option is speified it overrides the setting of B<LAZY> for individual
mount-points as well as the setting of the fallback B<$lazy>.

B<value> must be one of the following:

=over 16

=item B<0> (or the empty string)

Fail if umounting fails.

=item B<1> (default unless configured in F</etc/squashmount.pl>)

If umounting fails, retry B<umount --lazy>.

=item B<-1>

Try only B<umount --lazy>. Note that lazy umounting can be dangerous.
Use B<-1> only if you know what you are doing.

=back

=item B<--lsof=>I<value> or B<-l> I<value>

If this option is speified it overrides the setting of B<LSOF> for individual
mount-points as well as the setting of the fallback B<$lsof>.

B<value> must be one of the following:

=over 16

=item (the empty string)

Never execute B<lsof>.

=item B<0>

If B<lsof> indicates that umounting would fail, act as if B<$lazy=1>.

=item B<1> (default if B<$lsof> is unchanged in F</etc/squashmount.pl>)

Fail if B<lsof> indicates that umounting would fail.

=item B<-1>

If B<lsof> indicates that umounting would fail, act as if B<$lazy=-1>.
Use B<-1> only if you know what you are doing!

=back

=item B<--lsof-ro=>I<value>

If this option is speified it overrides the setting of B<LSOF_RO>
for individual mount-points as well as the setting of the fallback
B<$lsof_ro>.

It acts as B<--lsof>, but for the B<READONLY> directory.

=item B<--ll>

Prefer C<squashfuse_ll> over C<squashfuse> if available.
This is the default unless B<$squashfuse_ll> is set to a false value in the
configuration file F</etc/squashmount.pl>.

=item B<--no-ll> or B<--noll>

Do not use C<squashfuse_ll>.
This option overrides the setting of B<$squashfuse_ll> in the
configuration file F</etc/squashmount.pl>

=item B<--allow>

Use the option C<-o allow_other> for B<MOUNT_FUSE_OVERLAYFS>,
B<MOUNT_UNIONFS_FUSE>, B<MOUNT_FUNIONFS>, and B<MOUNT_SQUASHFUSE>
as default if these variables are not specified.
This is the default unless B<--user> is in use.

=item B<--no-allow> or B<--noallow>

Do not use the option C<-o allow_other> for B<MOUNT_FUSE_OVERLAYFS>,
B<MOUNT_UNIONFS_FUSE>, B<MOUNT_FUNIONFS>, and B<MOUNT_SQUASHFUSE>
as default if these variables are not specified.
This overrides the setting of B<--user>.

=item B<--locking>

Use perl's flock() to avoid simultaneous usage of the same mount-point.

=item B<--no-locking> or B<--nolocking>

This is the opposite of B<--locking>.
Whether B<--locking> or B<--no-locking> is the default depends on the
variable B<$locking> in F</etc/squashmount.pl> (the default in the latter
is true except if it is clear that no writing will be required).

=item B<--threshold=>I<size> or B<-t> I<size>

This is analogous to B<--no-squash> but will avoid the resquashing only if
there is less that I<size> bytes changed on disk.
(You can append B<k> or B<m> to I<size> to denote multiples of 1024 or 1024^2,
respectively.)
A negative number is equivalent to B<--no-squash>.
If I<size> is empty the value configured from F</etc/squashmount.pl> is taken.

=item B<--processors=>I<num> or B<-p> I<num>

Call B<mksquashfs> with the option B<-processors> I<num>.
If I<num> is empty or consists only of spaces, the option is not passed,
meaning that all available processors are used.

=item B<--mem=>I<bytes> or B<-m> I<bytes>

Call B<mksquashfs> with the option B<-mem> I<bytes>.
If I<bytes> is empty or consists only of spaces, the option is not passed.
In this case, the size depends on the B<mksquashfs> version;
some versions of B<mksquashfs> use in this case B<1954M>

=item B<--separator=>I<sep> or B<-S> I<sep>

When using B<check> or B<print-...> with option B<-q>,
I<sep> is appended to the output of each mount-point.
The default is a newline.

=item B<--pass-dir>

When this option is used, the passed arguments I<mask1> I<mask2> ... are
interpreted as names of mounted readonly or writable directories.
This is to allow this script to be used as a callback from umount-wrappers
like /sbin/umount.overlayfs or /sbin/umount.squashfs

=item B<--color> or B<-F>

Try to color even if output is not a terminal.

=item B<--no-color> or B<--nocolor> or B<-C>

Do not color the output.
Setting the environment variable B<ANSI_COLORS_DISABLED> has the same effect.

=item B<--no-star> or B<--nostar>

Omit printing C< * > at beginning of messages.

=item B<--star>

Print C< * > at beginning of messages.
This is currently the default, but this might change in future versions
of squashmount, at least for certain commands.

=item B<--title=>I<options> or B<-T> I<options>

The corresponding I<options> are passed to the title script to set the
hardstatus title. This option can be used accumulatively.
If at least one passed option is B<->, the title script is not used.

=item B<--error> or B<-e>

Do not process further mount-points when an error occurs.

=item B<--no-error> or B<--noerror> or B<-E>

Do not break on non-fatal errors but try to process all (matching) mount-points
if there is a chance to do so. This is the default.

=item B<--fatal>

Return nonzero exit status only on fatal errors.
In particular, the status will be zero even if the (u)mounting of some
mount-points failed.

This is the default with the commands B<start>, B<stop>, or B<restart>, because
this is probably  the appropriate behavior if called from an init-system.
For all other commands the default is:

=item B<--no-fatal> or  B<--nofatal>

Return nonzero exit status if the handling of at least one mount-point
produced an error.
This is the default except for the commands B<start>, B<stop>, or B<restart>,
see above

=item B<--first> or B<-1>

Only execute the first match, then end.

=item B<--arg=>I<argument> or B<-a> I<argument> (accumulative)

Add I<argument> to B<@ARGV> for the configuration file,
see the section B<ADVANCED CONFIGURATION>.

=item B<-->

Last option

=back

=head1 F</etc/squashmount.pl>

The file F</etc/squashmount.pl> can be any perl code which fills
the array B<@mounts> with references to hashes; one hash for every tag.
In addition, the arrays B<@order> and B<@squashorder> can be filled with
the available tools, the order in which they should be tried,
and flags whether modprobe should be called, how to test the existence of
tools and what to do if tools appear unavailable.
Also the default variables B<$lazy>, B<$lsof>, B<$lsof_ro>, B<$squashfuse_ll>,
B<$locking>, B<$modprobe_loop>, B<$obsolete_overlayfs>,
B<$resquash_on_start> can be initialized:
They are initialized to B<1> (perl interprets this as I<true>)
or B<''> (I<false>).
The arrays B<@umount>, B<@umount_ro>, B<@fumount>, B<@fumount_ro>
can carry default values for B<UMOUNT>, B<UMOUNT_RO>, B<FUMOUNT>, and
B<FUMOUNT_RO>, respectively.
The variable B<$rm_rundir> can be set to determine whether (and how)
the directory B</run/squashmount> should be removed.
Similarly, also the variables B<$rm_dir>, B<$rm_change>, B<$rm_workdir>,
B<$rm_readonly> can be set to determine default values for
B<RM_DIR>, B<RM_CHANGE>, B<RM_WORKDIR>, and B<RM_READONLY>.
Finally, also the variables B<$mksquash_verbose>,
B<$processors>, B<$mem> can specify the default values
if the corresponding options are not passed.

For advanced configuration, you can access the variables B<@ARGV>, B<$command>,
B<$storing>, and you can set callback functions/function arrays B<$before>,
B<$after>, B<$before_mount>, B<$after_mount>, B<$before_umount>, B<$after_umount>
which are explained in the section B<ADVANCED CONFIGURATION>.
There also some auxiliary perl functions available which are explained later on.

Here is an example for this file.
(You can use this syntax if you do not have much knowledge about perl;
if you know more about perl, a more convenient syntax is recommended,
see the remarks at the end of this manpage.)

=over 8

=item $lazy = $lsof = $lsof_ro = $squashfuse_ll = 1; # default

=item $killpower = '/etc/killpower';  # ignore /etc/nosquash /etc/nut/killpower

=item $locking = 1;  # lock always, even for status and print-* commands

=item $modprobe_loop = 1;  # Keep default: modprobe loop

=item $mksquash_verbose = 'qn-';  # quicker if we know mksquash -quiet works

=item $processors = '';  # unnecessary; this is the default

=item $mem = '';  # unnecessary; this is the default

=item $resquash_on_start = '';  # unnecessary; this is the default

=item $rm_rundir = 0;  # keep /run/squashmount

=item $rm_dir = $rm_workdir = $rm_changes = $rm_readonly = 0;  # keep dirs

=item @umount = ('-i');  # default to UMOUNT => [ '-i' ], ignoring --umount

=item @umount_ro = ();  # ignore option --umount-ro

=item $obsolete_overlayfs = undef;  # no fallback: require >=kernel-3.15

=item @order = qw(overlay? overlayfs? aufs! fuse-overlayfs! unionfs-fuse! unionfs??# funionfs??#);

=item # The main task is to set B<@mounts>. Use one of

=item # @mounts = ( { ... }, { ...} );

=item # push(@mounts, { ... }, { ... });

=item # (The latter can be used successively to append mount-points...)

=item @mounts = ( {

=over 16

=item TAG => 'useless_minimal',

=item DIR => '/usr/local',

=item FILE => '/usr/local.sfs',

=back

=item }, {

=over 16

=item TAG => 'guest',

=item DIR => '/home/guest'

=item FILE => '/home/guest-skeleton.sfs'

=item CHMOD => 0200,  # squash-file readonly by user

=item CHOWN => [ (getpwnam('guest'))[2], 1000 ],  # uid/gid

=item # CHOWN => '2000:1000' would also be possible

=item KILL => 1,  # Forget all changes when umounting

=item # For the exception that the user wants to resquash:

=item # We must not postpone resquashing since CHANGES is temporary:

=item RESQUASH_ON_START => '',  # Ignore setting of $resquash_on_start

=item RM_CHANGES => 1,  # remove temporary CHANGES on stop

=item RM_READONLY => 1,  # remove temporary READONLY on stop

=item RM_WORKDIR => 1,  # remove temporary WORKDIR on stop

=back

=item }, {

=over 16

=item TAG => 'tex',

=item DIR => '/usr/share/texmf-dist',

=item FILE => '/usr/share/texmf-dist.mount/texmf-dist.sfs',

=item CHANGES => '/usr/share/texmf-dist.mount/changes',

=item WORKDIR => '/usr/share/texmf-dist.mount/workdir',

=item READONLY => '/use/share/texmf-dist.mount/readonly',

=item DIFF => [ qr{^ls-R$},

=item qr{^tex(/generic(/config(/language(\.(dat(\.lua)?|def)))?)?)?$}n ],

=back

=item }, {

=over 16

=item # B<squashmount> plays nicely with the portage's

=item # B<sync-type = squashdelta>

=item # However, this requires another setup; see example configuration

=item # The following example is only useful for a "traditional"

=item # sync-type (like rsync, webrsync or also git).

=item TAG => 'portage',  # TAG => 'gentoo' should be reserved for

=item # /etc/portage/repo.postsync.d/10-squashmount-gentoo

=item DIR => '/usr/portage',

=item FILE => '/usr/portage.mount/portage.sfs',

=item CHANGES => '/usr/portage.mount/changes',

=item WORKDIR => '/usr/portage.mount/workdir',

=item READONLY => '/usr/portage.mount/readonly',

=item MKSQUASHFS => [ # Do not recompress git-compressed data

=item # See https://github.com/plougher/squashfs-tools/issues/24

=item '-action', 'uncompressed@subpathname(*/.git/objects/pack)' ],

=item THRESHOLD => '40m',  # resquash on umount if 40 MB changed, or

=item # if local/* (with * not .git, profiles, metadata) changed:

=item FILL => qr{^local/(?!(\.git|profiles|metadata)(/|$))}n,

=item # The |profiles|metadata might be too much. Instead, you can be

=item # be more explicit about the changes you do not care about, e.g.:

=item # DIFF => qr{^local(/profiles(/use\.local\.desc)?)?$}n,

=back

=item }, {

=over 16

=item TAG => 'fancy_temporary',

=item DIR => sub { return File::Temp::newdir() },

=item RM_DIR => 1, RM_CHANGES => 1, RM_WORKDIR => 1, RM_READONLY => 1,

=item CHANGES => sub { return File::Temp::newdir(undef, DIR => '/path/to/ramdisk') },

=item WORKDIR => sub { return File::Temp::newdir(undef, DIR => '/path/to/ramdisk') },

=item READONLY => \&make_temporary_subdir,

=item RESQUASH_ON_START => '',  # we must not postpone resquashing

=item FILE => '/just/a/crazy/example.sfs',

=item SKIP => '\A\.',  # A string is also possible (note: multiline mode)

=item SKIPDIR => qr{(^|/)tmp}ni,  # tmp* Tmp* TMP*

=item SKIPFUNC => sub { my ($rel, $abs, $ro) = @_; return (-d $abs) },

=back

=item });

=item sub make_temporary_subdir { my ($tag) = @_;

=over 16

=item my $dir = File::Temp::newdir(undef, CLEANUP => '')->dirname;

=item # CLEANUP => '' is crucial since we return only a string!

=item $dir .= "/$tag"; mkdir($dir); return $dir }

=back

=item 1;  # The last executed command should be a true expression

=back

Except for B<@mounts>, the meaning of the variables is easily explained:

=over 8

=item B<$lazy>

This determines the default I<value> of B<--lazy> for those mount-points
for which B<LAZY> is not defined.
See the description of B<--lazy> for details.
This variable defaults to the value B<1> (I<true>).

=item B<$lsof>

This determines the default I<value> of B<--lsof> for those mount-points
for which B<LSOF> is not defined.
See the description of B<--lsof> for details.
This variable defaults to the value B<1>.

=item B<$lsof_ro>

This determines the default I<value> of B<--lsof-ro> for those mount-points
for which B<LSOF> is not defined.
See the description of B<--lsof-ro> for details.
This variable defaults to the value B<1>.

=item B<$squashfuse_ll>

This determines whether B<--ll> or B<--no-ll> is the default.
This variable defaults to the value B<1> (I<true>), meaning that B<--ll>
is the default unless overridden in F</etc/squashmount.pl>.

=item B<$killpower>

This is a string or a reference to an array of strings.
If one of the strings is an existing file, then B<squashmount> behaves as
if option B<--no-squash> has been passed.
The default value is the array reference
B<[ '/etc/killpower', '/etc/nut/killpower', '/etc/killpower' ]>.
The explanation for this default follows.

The file F</etc/killpower> or F</etc/nut/killpower> is generated by
tools like B<nut> when an emergency shutdown is needed.
Consequently, by default, B<squashmount> will not try to resquash any data
when it is on an emergency shutdown caused by such a tool.

The file F</etc/nosquash> may be generated by you if you know that
you will reboot often (e.g. to test new kernels) and if you do not want to
resquash the data just for rebooting.
Note that for a single reboot, it is more convenient to call
B<squashmount -n set> instead, but this effect is gone after the reboot:
when one makes changes to the system which require a series of reboots
(e.g. tracking a bug in the kernel), it is easy to forget to call
this command before every single rebooting which can be quite annoying.
Therefore the file F</etc/nosquash> can be generated to keep this information
across reboots; of course, one should not forget to remove this file once
the series of reboots is finished.

=item B<$locking>

This determines whether B<--locking> or B<--no-locking> is the default.
This variable defaults to the value B<''> (I<false>) when query commands
like B<status> or B<print-*> are used; for all other commands it defaults to
B<1> (I<true>).

=item B<$obsolete_overlayfs>

This variable is only important when squashmount attempts to mount B<overlayfs>
(in contrast to B<overlay> which is contained in >=kernel-3.18)

When this perl variable is B<''> (I<false>), which is the default,
then it is attempted to mount overlayfs with the B<workdir> option
(required since overlayfs-22, i.e., since linux kernel-3.15),
and only if this fails, it is attempted to mount overlayfs without this option.
Undefine this variable if you do not want the latter.
In contrast, set this variable to B<1> (I<true>) if you have an obsolete
version of overlayfs (linux kernel less than 3.15): In this case, it is
first attempted to mount overlayfs without the B<workdir> option,
and the B<workdir> option is only attempted as a fallback if the former fails.

If you never want to use overlayfs with >=kernel-3.15 (and <kernel-3.18)
set B<$obsolete_overlayfs = 'force'>.

Not setting B<$obsolete_overlayfs> correctly should not cause any problems,
but it might lead to undesired warning/kernel messages and can cost some time.

=item B<$modprobe_loop>

This determines whether C<modprobe loop> is implied by modprobing for squashfs.
This variable defaults to the value B<1> (I<true>).

=item B<$resquash_on_start>

If this variable is B<1> (true), this becomes the default for
B<RESQUASH_ON_START> for all mount-points for which B<RESQUASH_ON_START>
is not explicitly set differently. It defaults to B<''> (I<false>).

=item B<$rm_rundir>

If this variable is a nonzero integer number then at B<squashmount stop>
the directory F</run/squashmount> is removed if it is empty.
If the number is bigger than 1, also the corresponding number of parent
directories (minus one) are removed (if nonempty). If the number is negative,
all parent directories are removed (if nonempty).
The default of this variable is B<1>.

=item B<$rm_dir>

=item B<$rm_changes>

=item B<$rm_workdir>

=item B<$rm_readonly>

These variables are taken as the defaults for B<RM_DIR>, B<RM_CHANGES>,
B<RM_WORKDIR>, or B<RM_READONLY>, respectively, if the latter variables
are not defined for a mount-point. The default of B<$rm_dir> is B<0>,
the default of the other three variables is B<1>.

=item B<$mksquash_verbose>

This is the default string if B<--squash-verbose> is not specified.
This variable defaults to B<q?n-n+!>
(if not overridden in B</etc/squashmount.pl>)

=item B<$processors>

This is the default string if B<--processors> is not specified.
If not set, the default is the empty string.

=item B<$mem>

This is the default string if B<--mem> is not specified.
If not set, the default is the empty string.

=item B<@umount>

This array determines the default for the values B<UMOUNT> if the
latter is not defined. Note that the default for B<@umount> in turn
is defined by the option B<--umount>.
In particular, if you set B<@umount> to a fixed value like C<@umount = ('-i');>,
the option B<--umount> will have no effect. You can use perl-code to combine
the option. For instance, when you use instead C<push(@umount, '-i');>,
the option B<-i> will be added to the options specified by B<--umount>.
Similarly, you can make a case distinction like
C<@umount = ('-i') unless (@umount);> in which case the option B<-i> will be
only used if no option was specified with B<--umount>.

=item B<@umount_ro>

This array determines the default for the values B<UMOUNT_RO> if the
latter is not defined. Note that the default for B<@umount_ro> in turn
is defined by the option B<--umount-ro>.
See the description of B<@umount> on the consequences of this.

=item B<@fumount>

This array determines the default for the values B<FUMOUNT> if the
latter is not defined.

=item B<@fumount_ro>

This array determines the default for the values B<FUMOUNT_RO> if the
latter is not defined.

=item B<@order>

This array determines in which order the overlay/aufs/... tools are tried
and/or whether it is attempted to modprobe them and on which conditions they
are (tacitly) skipped.

The first successful tool is chosen, and if all fail, B<mount --bind> is used.
The content of this array should be strings with one of the texts

=over 16

=item B<overlay>, B<overlayfs>, B<aufs>, B<fuse-overlayfs>, B<unionfs-fuse>, B<unionfs>, B<funionfs>, B<bind>

=back

for the corresponding tool. (Note that B<overlayfs> refers only to overlayfs
up to version 22 (available as a patch for <=linux-3.17); for >=linux-3.18
the corresponding filesystem is called B<overlay> in B<squashmount>.)

By default, it is attempted to B<modprobe> the corresponding module,
and if that B<modprobe> fails, the corresponding tool is tacitly skipped,
passing to the next tool in the list until the first succeeds.

If none succeeds, the fallback B<bind> is used (with an error message).
If B<bind> occurs explicitly in the list, no error message is emitted.

Optionally, you can append or prepend the following special flags to change
the default behavior with B<modprobe>.

=over 16

=item B<!> or B<!!>

If this flag is used, a failure in the modprobe command is ignored;
in case of B<!!> the modprobe is not even attempted.
In particular you should use this if it might happen (or you know) that the
corresponding tool is compiled directly into the kernel.
Note that B<overlayfs>, B<aufs>, B<unionfs> have their own kernel modules
while B<fuse-overlayfs>, B<unionfs-fuse> and B<funionfs> all require the
B<fuse> module and need special user space binaries.

=item B<?> or B<??>

If this flag is used and the B<modprobe> failed (or if combined with B<!!>)
the content of B</sys/modules> (or if that fails B</proc/config.gz>)
is checked for whether the corresponding tool appears available
in the running linux kernel.
If the tool appears unavailable it is tacitly skipped.
For the case that B</sys/modules> cannot be read and
B</proc/config.gz> cannot be read (the latter including the case
that the perl module B<IO::Uncompress::Gunzip> is unavailable) and the
B<??> variant is used, the tool is considered as unavailable.

=item B<#>

If this flag is used, it is checked whether the binary
(B<mount> in case of B<overlay>, B<overlayfs>, B<aufs>, or B<unionfs>
or the special user space binary for B<fuse-overlayfs>, B<unionfs-fuse>,
or B<funionfs>, respectively) is available in your path.
If it is unavailable, the tool is tacitly skipped.
This flag is ignored if neither B<File::Which> nor the B<which> program are
available.

=back

If B<squashmount> is used with a command for which the order is possibly needed
(B<start>, B<restart>, B<mount>, B<remount>), this array defaults to

=over 16

=item qw(overlay!? overlayfs!? aufs! fuse-overlayfs! unionfs-fuse! unionfs! funionfs!)

=back

This default means that all modules are loaded as required, with overlay and
overlayfs being tacitly skipped if the running kernel does not provide support
for it; all other tools are attempted in the order until the first succeeds,
no matter whether the kernel provides support for it.

If B<squashmount> is used with a different command, the default of this
array is empty.

=item B<@squashorder>

This array is rather analogous to B<@order> with the difference that it
determines the tool for mounting squash files.
The available tools are

=over 16

=item B<squashfs>, B<squashfuse>

=back

The same flags are available as for B<@order>. The default value is

=over 16

=item qw(squashfs!? squashfuse!)

=back

=back

The array B<@mounts> defines the various mount-points.
The first mount-point in the above example is the minimal data which
has to be specified for a mount-point.
However, typically you should also specify at least the keys B<CHANGES>,
B<WORKDIR> and usually also B<READONLY> unless you have a special reason not to.
The following keys are supported. If a key is undefined or not explicitly set,
a default value is chosen in some cases.

=over 8

=item B<TAG>

A unique identifier:
The B<TAG> is matched against the I<mask> entries on the command line.
The content must be alphanumeric; only the symbols B<.> B<-> B<_> are allowed.

=item B<DIR>

The absolute path of the main directory which you want to squash.

Alternatively, B<DIR> can be a function reference which returns a string to
the directory or alternatively a B<File::Temp::Dir> object.
This function is executed only once if B<DIR> is unknown and in this case
it gets passed the tag as an argument.
The intention is that this function can be used to return e.g. a temporary
dir name by using something like as in the B<fancy_temporary> example above.

Be aware that if this function uses B<File::Temp::newdir>, it should pass
B<CLEANUP =E<gt> ''> to avoid that the directory is magically removed
recursively: Forgetting this can severely damage your data!

As an exception, if the function returns the corresponding created object
(and not only a filename as in the B<make_temporary_subdir> example above),
B<squashmount> will care about disabling B<CLEANUP> automatically.
For this reason, we had lazily avoided B<CLEANUP =E<gt> ''> in some places
in the above B<fancy_temporary> example when calling B<File::Temp::newdir>.

If you use a temporary directory, you can find the actual used path with
B<squashmount print-dir ...>

=item B<FILE>

The absolute path to the squash-file which contains the actual data.

=item B<CHANGES>

The directory into which the changes to B<DIR> are stored.
If B<CHANGES> is not specified then a temporary directory is created
and used instead.

The same rules as for B<DIR> hold, that is, you can also pass a function which
explicitly calls B<File::Temp::newdir> with appropriate data.

Note that using a temporary directory may be dangerous since if temporary
directories are cleaned on boot this means that modifications to B<DIR>
are lost if they are not (successfully) squashed on shutdown
(e.g. due to option B<--no-squash>).
If you use a temporary directory, you can find the actual path with
B<squashmount print-changes ...>

=item B<WORKDIR>

The working directory required by overlay and overlayfs,
set according to the same rules as for B<CHANGES>.
If you want to use current versions of overlay or overlayfs
(linux-3.15 or newer) this B<must> be on the same filesystem as B<CHANGES>.
If you do not want to use B<WORKDIR>, set B<$obsolete_overlayfs = 'force'>
and use only overlayfs (not overlay).

=item B<READONLY>

If this is nonempty but not an absolute path, then B<DIR> is mounted readonly.
If this is an absolute path then a readonly version of the content of B<DIR>
is mounted here.
It is not possible to omit this directory if B<DIR> should be writable.
For the special case that B<READONLY> is empty, a temporary directly is used.

The same rules as for B<DIR> hold, that is, you can also pass a function which
explicitly calls File::Temp::newdir with appropriate data.

If you use a temporary directory, you can find the actual path with
B<squashmount print-readonly ...>

=item B<THRESHOLD>

This is the threshold value used for that mount-point
(unless changed by command line options).
Set it to B<-1> for an infinite threshold,
that is, to get the effect of B<--no-squash>.
Set it to B<-2> to force squashing even if there were no changes,
that is, to get the effect of B<--force-squash>.
The default is B<0>.

=item B<KILL>

If this is a positive number, B<--kill> is active for that mount-point.
If this is a negative number, B<--kill-or-resquash> is active for that
mount-point, that is, changes are killed unless they reach B<THRESHOLD>
(in the latter case, they are resquashed, as usual).
The value can be overridden by the corresponding command line options.

For backward compatibility, if B<KILL> is a nonempty string, it is treated
as a positive number.

=item B<RESQUASH_ON_START>

If this value is undefined, the value of the variable B<$resquash_on_start>
is considered instead; however, if it is defined, its value overrides the
global setting of B<$resquash_on_start>,

If the effective value is true (nonempty and not 0), then B<squashmount start>
attempts to resquash the data, and sets the B<-n> option for the mount-point
so that (by default) there is no resquashing of the data when
B<squashmount umount> or B<squashmount stop> is called (unless an option like
B<-s> is used later to override the previous B<-n>).

Thus, while the "default" operation of B<squashmount> is to resquash the
data on umounting (that is, as a rule, when you shut down the machine),
setting this variable (or B<$resquash_on_start>) causes "normally" the
resquashing to be postponed until the next start of the machine.

Of course, this makes only sense if your B<CHANGES> directory is not a
temporary directory which is cleaned during restarting: This is the reason
why you can set this variable individually for each mount-point.
Unless you have such exceptional mount-points, it is usually more convenient
to set the global default through B<$resquash_on_start>.

=item B<RM_DIR>

=item B<RM_CHANGES>

=item B<RM_WORKDIR>

=item B<RM_READONLY>

If this value is undefined, the value of the variable
B<$rm_dir>, B<$rm_changes>, B<$rm_workdir>, or B<$rm_readonly> is used
instead, respectively.

If the effective value is a nonzero number then with B<squashmount stop>
the corresponding directory is removed if it is empty.
If the number is bigger than 1, also the corresponding number of parent
directories (minus one) is removed (if nonempty). If the number is negative,
all parent directories are removed (if nonempty).

=item B<MKSQUASHFS>, B<COMPOPT_{XZ,LZMA,GZIP,LZO,LZ4,ZSTD,}>

These should be (possibly empty) strings or references to arrays of strings:
These strings are used as additional options when calling B<mksquashfs>
(the latter only if the corresponding B<COMPRESSION> option is used;
B<COMPOPT_> is used if B<COMPRESSION> is empty).
The option B<-noappend> is used automatically.
Depending on B<$squashfs_verbose>, B<COMPRESSION>, B<DEFAULT_FRAGMENTS>
also the options B<-no-progress>, B<-comp>, or B<-always-use-fragments>
are appended automatically.
If the corresponding variable is not defined, it is assumed to be empty
with the following exception:

=over 16

=item B<COMPOPT_ZSTD>: If undefined, defaults to
C<['-Xcompression-level', '22']>.
Set it to the empty string if you want the fast B<zstd> compression default
used by mksquashfs.

=item B<COMPOPT_LZ4>: If undefined, defaults to C<'-Xhc'>.
Set it to the empty string if you want fastest B<lz4> compression instead.

=back

=item B<TAR>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when calling B<tar>
If the corresponding variable is not defined, it is assumed to be
B<--numeric-owner>.

=item B<TAR2SQFS>, B<COMPEXTRA_{XZ,LZMA,GZIP,LZO,LZ4,ZSTD,}>

These should be (possibly empty) strings or references to arrays of strings:
These strings are used as additional options when calling B<tar2sqfs>
(the latter only if the corresponding B<COMPRESSION> option is used;
B<COMPEXTRA_> is used if B<COMPRESSION> is empty).
The option B<-f> is used automatically.
Depending on B<COMPRESSION>, also the option B<-c> is appended automatically.
If the corresponding variable is not defined, it is assumed to be empty
with the following exception:

=over 16

=item b<TAR2SQFS>: If undefined, defaults to C<-q>.
Set it to the empty string if you want to see all files listed on compression

=item B<COMPEXTRA_ZSTD>: If undefined, defaults to C<'level=22'>.
Set it to the empty string if you want the fast B<zstd> compression default
used by tar2sqfs.

=item B<COMPEXTRA_LZ4>: If undefined, defaults to C<'hc'>.
Set it to the empty string if you want fastest B<lz4> compression instead.

=back

=item B<MOUNT_OVERLAY>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with overlay.
(Note that overlayfs is available only for >=kernel-3.18;
see B<MOUNT_OVERLAYFS> for older versions).
The default is B<['-o', 'noatime', '-o', 'index=off']>.

=item B<MOUNT_OVERLAYFS>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with overlayfs.
(Note that overlayfs is available only for <kernel-3.18;
see B<MOUNT_OVERLAY> for newer versions).
The default is B<['-o', 'noatime']>.

=item B<MOUNT_AUFS>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with aufs.
The default is B<['-o', 'noatime']>.

=item B<MOUNT_FUSE_OVERLAYFS>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with fuse-overlayfs.
The default is B<['-o', 'allow_other', '-o', 'use_ino', '-o', 'nonempty',
'-o', 'noatime']>.

=item B<MOUNT_UNIONFS_FUSE>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with unionfs-fuse.
The default is B<['-o', 'cow', '-o', 'allow_other', '-o', 'use_ino',
'-o', 'nonempty', '-o', 'noatime', '-o', 'hide_meta_files']>.

=item B<MOUNT_UNIONFS>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with unionfs.
The default is B<['-o', 'noatime']>.

=item B<MOUNT_FUNIONFS>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with funionfs.
The default is B<['-o', 'allow_other', '-o', 'nonempty']>.

=item B<MOUNT_SQUASHFUSE>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with squashfuse.
The default is B<['-o', 'allow_other', '-o', 'nonempty']>.

=item B<UMOUNT>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when umounting B<DIR>
(see also B<UMOUNT_RO>).
If nothing is specified, the value of B<@umount> is used whose default in
turn is set by the option B<--umount>.
Note that if this value is specified, the values of B<@umount> (and thus
the option B<--umount>) is completely ignored. You can use perl-code if you
do not want this. For instance, C<UMOUNT => [ @umount, '-r' ]> will add
the option B<-r> to that specified through B<@umount>. Similarly,
C<UMOUNT => ((@umount) ? '-r' : undef)> will use the option B<-r> if
nothing was specified in B<@umount> (or through the option B<--umount>),
otherwise, it will use the default (i.e. the value of B<@umount>).

=item B<FUMOUNT>

This is analogous to B<UMOUNT>, but when B<fusermount -u> is used.

=item B<UMOUNT_RO>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when umounting a readonly
directory. If nothing is specified, the value of B<@umount_ro> is used whose
default in turn is set by the option B<--umount_ro>.
See the description of B<UMOUNT> on the consequences of this.

=item B<FUMOUNT_RO>

This is analogous to B<UMOUNT_RO>, but when B<fusermount -u> is used.

=item B<COMPRESSION>

Specifies the compression mode for B<mksquashfs>:
The available values depend on the installed version of B<mksquashfs>;
typically B<xz>, B<lzma>, B<gzip>, B<lzo>, B<lz4>, and B<zstd> are available
(ordered in increasing compression ratio, i.e. B<xz> is usually the slowest but
best in compression ratio while B<lz4> is the quickest; B<zstd> can be both,
depending on the value of B<COMPOPT_STD> or B<COMPOPT_EXTRA>, see above).
If the value is empty, no B<-comp> parameter is passed,
that is, the default of the installed B<mksquashfs> is chosen
(which is usually B<gzip> but might depend on your version of B<mksquashfs>).
The default of B<COMPRESSION> (that is, if undefined or not explicitly set)
is B<zstd>; note that before B<squashmount>-17.0.0/10.0.0 this was
B<lz4>/B<xz>.
Note also that B<zstd>/B<lz4> support requires linux-4.14/3.19 or newer
(or squashfuse-0.1.101_alpha20170917/0.1.100_alpha20140523 or newer).

=item B<DEFAULT_FRAGMENTS>

Unless this variable is a nonempty string,
B<-always-use-fragments> is appended to the options of B<mksquashfs>
which usually improves the compression ratio.
You might need to set this variable (at the cost of slightly worse results)
if you need compatibility with older versions of B<squashfs>.

=item B<LAZY>

This variable can be used to override the default B<$lazy> for the mount-point.
If the option B<--lazy> is specified, it overrides this value.
See the description of B<--lazy> for the possible values and their meaning.

=item B<LSOF>

This variable can be used to override the default B<$lsof> for the mount-point.
If the option B<--lsof> is specified, it overrides this value.
See the description of B<--lsof> for the possible values and their meaning.

=item B<LSOF_RO>

This variable can be used to override the default B<$lsof_ro> for the
mount-point.
If the option B<--lsof-ro> is specified, it overrides this value.
See the description of B<--lsof-ro> for possible values and their meaning.

=item B<BACKUP>

If this is set to an absolute path, then when resquashing B<FILE>,
a copy of the old version is moved to that path.
If the file B<BACKUP> already exists, it is removed.

If B<BACKUP> is not an absolute path but nonempty, the path is that of
B<FILE> with the value of B<BACKUP> appended.
If B<BACKUP> is empty, no backup is made.

=item B<CHMOD>

If defined and nonempty this should be a number (if you want an octal number,
do not enclose into quotes and start with a leading B<0>, or otherwise
use perl's B<oct(>I<decimal number>B<)> function).
The number defines the mode to which the squash-file is changed with B<chmod>
whenever it is created.
The empty string means that the mode remains B<0400>.
If undefined (the default), the mode B<0644> is taken.

=item B<CHOWN>

If defined and nonempty this should be either an array reference B<[> I<uid>B<,> I<gid> B<]>
or a string of the form I<uid>B<:>I<gid>; in this case, the user/group id of
the file is changed to I<uid>/I<gid>, respectively.
Use the undefined or empty value or B<-1> to indicate that I<uid>/I<gid>
should not be changed (typically remains B<0>).
If you want to pass the user or group name (instead of the user or group id),
you can use e.g. the perl construct B<(getpwnam('>I<username>B<'))[2]> or
B<(getgrnam('>I<groupname>B<'))[2]>, respectively.

=item B<CHMOD_DIR>

If this is defined and a number (see B<CHMOD> for octal numbers),
then it is attempted to change the mode of B<DIR> to this number
after successfully mounting B<DIR>.

=item B<CHOWN_DIR>

If defined and nonempty this should be in the same format as in B<CHOWN>.
In this case, B<DIR> is changed to the corresponding user/group after
successfully mounting. Note that this usually implicitly changes the
permissions of B<CHANGES> as well, but this can depend on the tool which
is used to merge the directories.

=item B<TEMPDIR>

The new version of the squashed data is first created in a temporary file.
If B<TEMPDIR> is set it is created in this directory.
It is useful to choose a directory on a harddisk if the regular temporary
directory is a ramdisk with less space than the expected filesize.
If you choose a harddisk, things will be faster if you choose the same
partition on which the squash-file B<FILE> resides.

=item B<BLOCKSIZE>

The size of one disk-block when calculating the changed data for the threshold.
The default is 4096.
The blocksize does not have to be in relation with the physical blocksize.
For instance, if you a directory with small files, it might be a good idea
to set B<BLOCKSIZE> to a huge value so that the calculation for the
threshold is essentially based on the number of files (instead of their size).

=item B<SKIP>

This is a regular expression (or a string which will be interpreted as
a regular expression in multiline mode), or a reference to an array of
regular expressions/strings.
If you use braces () in a regular expression, it is recommended to use
the C<n> flag to speed up the processing, e.g. C<qr{root/(foo|bar)}n>.

For each file/directory in B<CHANGES> (except F<.> and F<..> directories)
its path (relative to B<CHANGES>) is matched against these regular expressions.
If the file matches, it is not considered as being changed.
This is useful to avoid squashing only because e.g. a known temporary
file has changed in this directory which you do not care about.

When all changes are skipped during umounting, the B<CHANGES> directory
is cleaned anyway, i.e. skipping a file means that changes to
this file are usually lost (unless the directory is resquashed anyway).

If a file you want to skip resides in a subdirectory (not in the root
of B<CHANGES>) you probably also want to skip all parent directories,
because overlay/overlayfs/aufs/... has to create them to create the file.
However, to be more careful you might want skip them with B<DIFF>
(as that will check that it is really a directory and exists in B<READONLY>).

=item B<SKIPDIR>

This is similar to B<SKIP>, but only for directories; moreover, also the
whole content of matching directories is being considered as unchanged.

If you want to B<SKIPDIR> a directory lying not in the root of B<CHANGES>,
you will probably want to include its parent directories to B<DIFF>
(or to B<SKIP> if you are less careful).

=item B<DIFF>

This is similar to B<SKIP>, but a little bit more careful:
The file/directory is only considered unchanged if it is the same as the
corresponding file in the B<READONLY> directory, up to possibly
permissions or time stamps.
This is to avoid resquashing just because some timestamps or permissions
were changed.

As for B<SKIP> and B<SKIPDIR>, for files in subdirectories you will probably
also want to include the parent directories here.
As an example, to ignore changes only in timestamps or permissions of
the files

=over 16

=item F<tex/generic/config/language.dat>

=item F<tex/generic/config/language.dat.lua>

=item F<tex/generic/config/language.def>

=back

you must also ignore that the corresponding parents are created in B<CHANGES>.
Therefore, in the example file above (in TAG tex), the regular expression
in B<DIFF> not only matches the above files but also their parent directories.

To match for files, it might be convenient to use several regular expressions
(or strings): All related variables B<SKIP>, B<SKIPDIR>, B<DIFF> accept also
references to arrays of regular expressions. See e.g. B<SKIPDIR> in
in the fancy_temporary example above.
Note in that example also that you can can pass regular expressions
instead of strings. This way you can pass e.g. perl flags to ignore case.

=item B<SKIPFUNC>

This is the most generic form of B<SKIP>, B<SKIPDIR>, B<DIFF>:
This is a reference to a function which can decide whether the file is being
considered as changed.
The function gets passed three parameters: The relative filename,
the absolute filename, and the corresponding pathname in the READONLY directory.
The function must return a true value (e.g. 1) if the file should not be
considered as changed.
If the function sets B<$File::Find::prune = 1> in case of a directory
then its content is not considered as changed, either.

In the above B<fancy_temporary> example, this functions is used to ignore all
added/modified (empty) directories.

=item B<FILL>

This is similar to B<SKIP>, but with the opposite meaning:
If there is a matching file/directory then any positive value of
B<THRESHOLD> is considered as reached by the corresponding data.
If B<SKIP>, B<SKIPDIR>, B<DIFF>, or B<SKIPFUNC> apply also, these
take precedence over B<FILL> or B<FILLFUNC>.

=item B<FILLFUNC>

This is the analogue of B<SKIPFUNC>, but corresponding to B<FILL> instead of B<SKIP>.
If the function returns a true value (e.g. 1) the threshold is considered as filled.
This function has no need to modify B<$File::Find::prune>.

=back

It is intentional that F</etc/squashmount.pl> is ordinary perl code so that
you can use all sort of perl features if you like.

Here are some examples why this might be useful:

=over 8

=item B<(1)> You can source other config files/directories at your discretion.

=item B<(2)> You can even interpret other config files in a format you prefer.

=item B<(3)> You can make setups based on the existence of symlinks or dirs.

=item B<(4)> You can use more complex code to setup B<@order>.

=item B<(5)> You can use various shortcuts to setup "standard" mount-points.

=item B<(6)> You can define some keys as "defaults" for all mount-points.

=back

In any case, it is recommended to not use B<too> much code since the code
will be parsed/executed with every call of B<squashmount>.
In particular, if you want some more complex code to setup B<@order> according
to you system, it is recommended to enclose this code into C<if (@order)> so
that this code is only executed if the value of B<@order> is really needed.
(Recall that the default of B<@order> is nonempty only if B<squashmount> is
used with a command for which it might be necessary to know its value.)

To use some of the mentioned features you need some perl knowledge, of course.
However, others are easy to use even without deep perl knowledge.
In particular, concerning B<(5)> and B<(6)>, B<squashmount> provides two
functions which make this task relatively easy:

=over 8

=item B<standard_mount(>I<tag>B<,> I<dir>, ...B<)>

This function returns a reference to a hash with the keys B<TAG> and B<DIR>
filled according to the first two arguments.
In addition, the values for the keys B<CHANGES>, B<WORKDIR>, B<READONLY>,
and B<FILE> are generated by just appending B<.mount/changes>,
B<.mount/workdir>, B<.mount/readonly>, B<.mount/>I<dirname>B<.sfs>.
Moreover, if I<...> are references to hashes, they are added to the hash:
Later hash entries override earlier ones unless the values itself are hashes
or arrays; so, for instance setting a value to C<undef> in a sense cancels
a previous definition. If a hash entry itself is a hash or array reference,
it does not replace the previous value but is added to it (provided that
the previous value was a hash or array reference or a single string,
respectively). Adding hash references to hash references works recursively.

I<dir> can also be an array reference: This is equivalent to calling
B<standard_mount> successively with each I<dir> value from the array;
if the array contains more than one entry, the I<tag> value is modified
by appending successibe numbers B<1>, B<2>, ... Alternatively,
additionally I<tag> can be a reference to an array with two entries
B<[>I<singletag>B<,> I<multitag>B<]>. If I<dir> refers to at most 1 directory
(i.e. if I<dir> is a string or an arrray of length 1) then the first entry
I<singletag> is used. Otherwise, B<sprintf(>I<multitag>, I<number>B<)> is used
to generate a tag. Example:

B<push(@mounts, standard_mount(["rust64", "rust%d_64"], [glob("/usr/lib64/rust*[0-9]")]))>

will generate mount-points for all directories matching B</usr/lib64/rust*[0-9]>
under the tags B<rust1_64>, B<rust2_64>, ... but if there is only one match,
then it will use the tag B<rust64> instead. As a special case, if the array
referred by I<dir> is empty (that is, if the B<glob> in the example returns
nothing), then also B<standard_mount> returns the empty array (that is, the
B<push> in the example does nothing).

=item B<added_hash(>I<hashref>B<,> ...B<)>

This function returns a reference to a hash which merges all hashes,
that is, it is like B<standard_mount()> except that it does
not fill a hash with certain values first.
The idea is that this function can be used to start with a "default" hash
and override/modify/add some data at your discretion.

For perl specialists: This function is similar to the one provided
by B<Hash::Merge::Simple>, but it does not require the existence of that
perl module and can add arrays to strings.

=item B<envlibs(>I<files>, I<prefix>B<)>

This is a helper function which is mainly meant to be used for Gentoo systems.
I<files> is a string or a reference to an array of strings. The function
parses all ordinary files from I<files> and returns an array of every
I<path> which occurs in these files in a line starting with
B<LDPATH=">I<path>B<">. If I<prefix> is passed, it is prepended to all
returned paths. Example:

B<envlibs([glob("/etc/env.d/*rust-*")])>

returns an array of all used rust libraries on a Gentoo system.
To pass this array as a reference to B<standard_mount>, one can use:

B<standard_mount('rust', [envlibs([glob("/etc/env.d/*rust-*")])])>

=back

Here is an example how to use B<standard_mount>
to specify the portage mount-point from
the first example and additionally a "standard" mount-point (analogously
to the portage mount-point but with different paths and without the
B<THRESHOLD> option) in a shorter way:

=over 8

=item push(@mounts,

=over 16

=item standard_mount('portage, '/usr/portage', {

=over 24

=item THRESHOLD => '40m',

=back

=item }),

=item standard_mount('kernel', '/usr/src')

=back

=item );

=back

It is recommended to use a perl variable like B<$defaults> to contain
a reference to a hash with data which you want to specify for practically
every mount-point like B<COMPRESSION> or B<TEMPDIR> and to add this
variable to every point-mount.
This way you can easily change the defaults without manipulating every
mount-point entry manually. (You can still override $defaults
for particular mount-points at your discretion.)
Here is such an example which also demonstrates the use of B<added_hash()>:

=over 8

=item my $tempdir = { TEMPDIR => '/my/ramdisk' };

=item my $always = { COMPRESSION => 'gzip', THRESHOLD => '20m' };

=item my $defaults =  added_hash($always, { BACKUP => '.bak' }, $tempdir);

=item # Adding $git will not recompress git-compressed data.

=item # See https://github.com/plougher/squashfs-tools/issues/24

=item my $git = { MKSQUASHFS => [

=item '-action', 'uncompressed@subpathname(*/.git/objects/pack)' ],

=item };

=item push(@mounts,

=over 16

=item standard_mount('portage', '/usr/portage', $defaults, $git),

=item standard_mount('kernel', '/usr/src', $defaults, $git),

=item standard_mount('games', '/usr/share/games', $defaults, {

=over 24

=item READONLY => undef  # cancel standard definition

=back

=item })

=back

=item );

=back

=head1 ADVANCED CONFIGURATION

Since the configuration file consists of perl code, you can do all sort of
conditional configuration in the configuration code.

For instance, you can use the same configuration file for different machines,
making the behavior depend on the hostname. Here is such an example:

=over 8

=item use Sys::Hostname;  # Use a module to fetch the hostname

=item # The environment variable B<HOSTNAME> can override the hostname

=item my $hostname = ($ENV{'HOSTNAME'} // hostname());

=back

=over 8

=item # Here can be configuration common for all hosts...

=back

=over 8


=item if ($hostname =~ m{^(foo|bar)$}n) {

=over 16

=item # Configuration for hosts 'foo' and 'bar' only

=back

=item } elsif ($hostname eq 'bazola') {

=over 16

=item # Configuration for host 'bazola' only

=back

=item } else {

=over 16

=item # Configuration for all other hosts only

=back

=item }

=back

=over 8

=item # Configuration common for all hosts

=back

In some cases, you might want to make the configuration even dependent on
the command line. For instance, you might want that certain mount-points
are not visible during the "regular" B<squashmount start> but must be activated
explicitly. Or you might want to make a certain path dependent on an option
passed on the command line.

For this reason, it is possible to pass arguments from the command line
to the configuration file with B<-a> I<argument> (or B<--arg=>I<argument>):
Arguments passed this way are collected in the array B<@ARGV> which can be
accessed from within the configuration.

You can use the functions B<info>(), B<warning>(), B<error>(), B<errorinfo>(),
and B<fatal>() to output information to the user: All of these functions
take arbitrary many arguments, each argument is output into a separate line
(somewhat formatted according to the context).
The function B<fatal>() also finishes B<squashmount> with exit status B<1>;
the difference between B<error>() and B<errorinfo>() is that the latter
does not output the text "error".

However, some care has to be taken. For instance, even if you want to hide
certain mount-points from B<squashmount start> (or maybe also from
B<squashmount mount>) for "normal" usage, you will probably not want to
hide that mount-point from B<squashmount stop> (or maybe also not from
B<squashmount umount>), since you probably want that the mount-point is
umounted during shutdown.

For this reason, you can see the currently used command in the perl variable
B<$command>. This variable contains the actual command (even if the user
used a shortcut like B<l> instead of B<list> on the command line);
the command B<list> appears as B<status>.

Special care has to be taken with "variable data" (that is, with data
in mount-points which may differ for different calls of B<squashmount>):
In many occasions, B<squashmount> will store the effective data for later
calls of B<squashmount>, and once this has happened, the stored data usually
overrides the paths from the configuration file.
This is almost always what you want:

Suppose that you have a mount-point with a "variable data" B<DIR>.
If B<DIR> was F</foo/bar> in the moment when B<squash start> is called,
then F</foo/bar> is also used for B<squash umount>, that is, you do not
need to remember that B<DIR> to umount the correct directories.

However, this can also be undesired: Once you umounted this directory,
also the next mount will access the same path, that is, you cannot really
have a "variable" B<DIR> using successively different paths.
A "workaround" for this problem is to use B<squashmount stop>
(or B<squashmount forget>) or to override the corresponding data
in a callback function (see below).

It is explicitly not specified precisely which data is stored, how and when:
This might change in future versions of B<squashmount>,
so do not rely on anything.

The only thing you can rely on in this connection is that data is only stored
if B<$storing> is true: The variable B<$storing> defaults to the same value
as B<$locking>.

It is possible to change the variable B<$storing> in the configuration file.
If you do this, you should probably also change the value of B<$locking>
correspondingly. While it is usually not a problem if you set B<$storing>
and B<$locking> to a true value, you will hardly ever have a reason to set
B<$storing> to a false value. For instance, for B<squashmount mount>,
this would mean that B<squashmount> would not store the information
that the mount-points are now mounted, and so a subsequent
B<squashmount umount> would then fail.

It is admissible (and recommended for conditional mount-points) to check
whether there is any data stored for a certain mount-point.
A function is provided to do this cleanly:

=over 8

=item B<have_stored_data(>I<name of mount-point>B<)>

=back

will return true (B<1>) or false B<('')> depending on whether B<squashmount>
has data stored for that mount-point.
It is recommended to use only this function and the callback
mechanisms described later on when you want to know something about
the data stored by B<squashmount>.

Here is an example which generates a mount-point from a squash-file of a CD
(from a fixed path) only if the option B<-a -c> or B<--arg=--cd> is passed
to B<squashmount>.

=over 8

=item my $cd = '';  # We set $cd = 1 if the mount-point is available

=back

=over 8

=item # Make the mount-point available via options.

=item # (We use B<GetOptions()> here just to illustrate that

=item # B<@ARGV> can be treated with usual perl tools.)

=item require Getopt::Long;

=item Getopt::Long::GetOptions('cd|c', \$cd);

=back

=over 8

=item # The following is important: Make the mount-point available

=item # whenever squashmount has data stored for it.

=item # Thus, the mount-point 'cd' is recognized once it is mounted,

=item # even if you do not pass any special options.

=item # In particular, when the init-system calls B<squashmount stop>,

=item # it will also shut down the mount-point 'cd' properly.

=item $cd ||= have_stored_data('cd');

=back

=over 8

=item # Finally, we (conditionally) add the mount-point to @mounts,

=item # using "standard" paths except for B<FILE>:

=item push(@mounts, standard_mount('cd', '/var/cd', {

=over 16

=item FILE => '/path/to/squashfile/on/cd'

=back

=item })) if ($cd);  # under the condition that $cd is true

=back

=over 8

=item # If this is the end of the file, do not forget:

=item 1;  # The last executed command should be a true expression

=back

The callback mechanism mentioned earlier consists in setting at least one of
the variables B<$before>, B<$after>, B<$before_mount>, B<$after_mount>,
B<$before_umount>, $B<$after_umount> to a function or a reference
to an array of functions, respectively.
These functions are called for each mount-point immediately before/after
B<squashmount> executes its main task (specified by B<$command>), or
before/after B<squashmount> is executes its main mount/umount command(s).

Note that e.g. B<$before_mount> can be called several times successively
for the same mount-point if B<RESQUASH_ON_START> is true.

These functions are called with three parameters: The name of the mount-point
(a string), a reference to the hash containing the "stored" data,
and a reference to a hash containing the "configuration" data for that
mount-point. These functions should always return B<1> (unless you want
to indicate an error with a special functionality, see below).
Note that the "stored" data usually overrides the "configuration" data.

You can not only read these hashes but also modify them: Modifying data in
a function from B<$before> can influence of course also the behavior of the
subsequent main task, while modifying the hash of "stored" data in a function
from B<$after> only influences what will be stored for later calls of
B<squashmount>. You can add new keys to the hash of "stored" data, but the
values must be very simple: Only strings (or numericals) are admissible.

The modified data is only stored if B<$storing> is true. Changing
the value of B<$storing> in any of the callback functions is not admissible:
If you want to change B<$storing> (and then probably also B<$locking>)
you must do this only when the configuration file is parsed.

Note that all of the hook functions must return a value, and
this value should usually be true (e.g. B<1>): If a function from B<$before>
does not return true, then no further function from B<$before> is executed,
and also the main action of B<squashmount> is not executed for that mount-point
and considered to be failed. If a function from B<$after> does not return
true, then no further function from B<$after> is executed, and
B<squashmount> will not store any data for that mount-point.
Be aware that the latter means that you can run into the same problems
as if you set B<$storing> to a false value: If B<squashmount> just mounted
a mount-point, it will not "know" that it did this afterwards, if the
data is not stored!

In a similar way, a non-true return value of B<$before_mount> or
B<$before_umount> indicates that the (u)mounting failed without actually
attempting to (u)mount, and a non-true return value of B<$after_mount> or
B<$after_umount> indicates that the (u)mounting failed.

In the functions from B<$after>, you should not add/modify any data to the
hash of "stored" data if B<$command> is B<forget> or B<stop>:
Otherwise, the data is stored, as required by you, and so the above mentioned
function B<have_stored_data> will return a true value, contradicting the
documented behavior of B<forget> and B<stop>!

Here is an example which is more advanced than the previous one:
With this example, you can specify the path of the squash-file by
calling B<squashmount> with the arguments B<-a> I<path> or B<--arg=>I<path>.
When mounted, this path will be stored for later usage, until the setting
is forgotten with B<squashmount stop> or B<squashmount forget>.
The mount-point is only visible if either the argument B<-a> is used or if
the path is already stored.

=over 8

=item my $cd = @ARGV;

=item my $file = '/default.sfs';

=item if ($cd) {

=over 16

=item (-f ($file = pop(@ARGV))) or

=item fatal("argument '$file' of --arg is not a file");

=item # If --arg was provided once, store it for later usage

=item $locking = $storing = 1  # don't set $storing without $locking!

=back

=item }

=item # The following is important (see previous example)

=item $cd ||= have_stored_data('cd');

=item # We use a callback function to store/restore $file:

=item $before = sub {

=over 16

=item my ($mountpoint, $store, $config) = @_;

=item return 1 unless ($mountpoint eq 'cd');

=item # Store $file only if not already done: Do not allow modification!

=item $config->{FILE} = ($store->{FILE} //= $file);

=item 1  # return a true value!

=back

=item };

=item # Make the mount-point conditionally available (see previous example)

=item push(@mounts,

=over 16

=item standard_mount('cd', '/var/cd', {

=over 24

=item FILE => $file

=back

=item })

=back

=item ) if ($cd);

=item 1;

=back

In the above code, the value of B<--arg> is ignored if it is already stored.
This is intentional, since it may be dangerous to change the path of FILE
while it is mounted. A more luxury variant of the above code would also
print a warning if the user attempts to use different values for B<--arg>
without calling B<squashmount stop> (or B<squashmount forget>) in between.

Here is an example of the usage of some of the other hooks.
In this example, the hooks are used to bind a copy of the mounted directory
from the "portage" mount-point to /srv/copy

=over 8

=item $after_mount = sub {

=over 16

=item my ($mountpoint, $store, $config) = @_;

=item return 1 unless ($mountpoint eq 'portage');

=item system('mount', '--bind', $config->{DIR} // $store->{DIR}, '/srv/copy');

=item 1  # return a true value!

=back

=item };

=item $before_umount = sub {

=over 16

=item my ($mountpoint, $store, $config) = @_;

=item return 1 unless ($mountpoint eq 'portage');

=item system('umount /srv/copy');

=item 1  # return a true value!

=back

=item };

=back

=head1 COPYRIGHT AND LICENSE

Copyright Martin VE<auml>th.
This project is under the BSD license 2.0 ("3-clause BSD license").

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

# Special paths:

my $root = File::Spec->rootdir();
my $devnull = File::Spec->devnull();
my $rootdata = undef;

# Default for the Options:

my @allow_other = ('-o', 'allow_other');
my @title = ();
my $verbose = 0;
my $quiet = 0;
my $mksquash_verbose = undef;
my $processors = undef;
my $mem = undef;
my $opt_color = undef;
my $star = undef;
my $lazy = undef;
my $opt_lazy = undef;
my $lsof = undef;
my $opt_lsof = undef;
my $lsof_ro = undef;
my $opt_lsof_ro = undef;
my $squashfuse_ll = undef;
my $locking = undef;
my $use_tar2sqfs = undef;
my $force = '';
my $ignore_state = '';
my $reset = '';
my $interactive = '';
my $opt_threshold = '';
my $opt_kill = undef;
my $opt_backup = undef;
my $opt_tempdir = undef;
my $opt_compression = undef;
my $opt_order = undef;
my $opt_squashorder = undef;
my $opt_user = undef;
my $opt_allow_other = undef;
my $opt_root = undef;
my @order = ();
my @squashorder = ();
my @bind = ();
my $pass_dir = '';
my $errorbreak = '';
my $fatalreturn = undef;
my $firstmatch = '';
my @configs = ();
my @system_configs = ();
my @argv = ();
my $separator = "\n";
my $rundir = undef;
my $titleopt = undef;

# Paths to executables:

my $title = undef;
my $funionfs = undef;
my $fuse_overlayfs = undef;
my $unionfs_fuse = undef;
my $squashfuse = undef;
my $mksquashfs = undef;
my $tar = undef;
my $tar2sqfs = undef;
my $lsof_bin = undef;
my $mount = undef;
my $umount = undef;
my $fusermount = undef;
my $modprobe = undef;

# Global/State variables:

our $VERSION;
my $run_ro;                # handle /run/squashmount as readonly
my $modprobe_loop;         # modprobing loop is implies by modprobing squash
my $resquash_on_start;     # default for resquash_on_start
my $rm_rundir_on_end;
my $rm_rundir;
my $rm_dir;
my $rm_changes;
my $rm_workdir;
my $rm_readonly;
my $lockfh = undef;
my $stdoutterm = ((-t STDOUT) // '');  # whether stdout is a terminal
my $stderrterm = undef;    # whether stderr is a terminal
my $know_quiet = undef;    # whether mksquash accepts -quiet
my $mksquash_symbols = undef;
my $exitstatus = 0;
my $had_error = '';
my $current = undef;       # current configuration in /run/squashmount
my $current_empty;         # if defined and equal to $current, will remove file
my $user_config = undef;   # current configuration in /etc/squashmount.pl
my $tag = '';              # $user_config->{'TAG'}
my $printed_title = '';    # Have we printed a statusline?
my $taglen;                # Length of the longest tag
my $threshold;             # currently active threshold (integer)
my $kill;                  # currently active kill (integer)
my $backup;                # currently active backup (string)
my $tempdir;               # currently active tempdir (string)
my $compression;           # currently active compression (string)
my $current_lazy;          # currently active lazy
my $current_lsof;          # currently active lsof
my $current_lsof_ro;       # currently active lsof_ro
my $name = 'squashmount';  # name of the program (this is actually a constant)

#
# Commands
#

sub cmd_mount {
	&mount_main('')
}

sub cmd_umount {
	return '' if (&error_unless_mounted());
	&umount_main()
}

sub cmd_remount {
	return '' if (&error_unless_mounted());
	&remount_main()
}

sub cmd_create {
	return '' if (&error_if_mounted());
	my $squashfile = &get_abspath('FILE', 1);
	if (-f $squashfile) {
		if ($force) {
			&warning("squash-file $squashfile already exists") unless ($quiet);
		} else {
			&error("squash-file $squashfile already exists");
			return ''
		}
	}
	return '' unless (&create_dir('DIR', 1));
	&first_create($squashfile, $current->{'DIR'})
}

sub cmd_start {
	&mount_main(1)
}

sub cmd_stop {
	if (&error_unless_mounted()) {
		&forget_settings() if ($force);
		return ''
	}
	return '' unless (&umount_main(1));
	&forget_settings();
	1
}

sub cmd_restart {
	my $ret;
	if (&error_unless_mounted()) {
		return '' unless ($force);
		$ret = ''
	} else {
		return '' unless (&umount_main(1));
		$ret = 1
	}
	&forget_settings();
	&mount_main(1) && $ret
}

sub cmd_forget {
	unless ($force || !&is_nonempty($current->{'TYPE'})) {
		&error('mounted, forget is not used');
		return ''
	}
	&forget_settings();
	1
}

sub cmd_set {
	$current->{'BACKUP'} = $backup;
	$current->{'TEMPDIR'} = $tempdir;
	$current->{'COMPRESSION'} = $compression;
	$current->{'THRESHOLD'} = $threshold;
	$current->{'KILL'} = $kill;
	1
}

sub cmd_reset {
	&reset_main(!$quiet)
}

sub cmd_check {
	my $dir = &get_abspath('DIR');
	unless (&is_abspath($dir)) {
		&error("DIR is not known yet; use first: $name -f print-dir");
		return 1
	}
	my $mounted = &is_nonempty($current->{'TYPE'});
	if ($mounted) {
		unless ($force) {
			&error('DIR is mounted. Use -f to umount temporarily');
			return 1
		}
		&info('umounting...') unless ($quiet);
		return '' unless (&umount_dir($dir, '', &is_fuse_type()));
		delete($current->{'TYPE'})
	}
	my $status = &dir_is_empty($dir);
	if ($status eq '') {
		if ($quiet) {
			&do_print('nonempty')
		} else {
			&error('DIR is nonempty!')
		}
	} elsif ($status) {
		&do_print($quiet ? '' : 'DIR is empty');
	} else {
		if ($quiet) {
			&do_print(undef)
		} else {
			&error("cannot open $dir")
		}
		$status = ''
	}
	return '' if ($mounted && !&mount_main('', 1));
	$status;
}

sub cmd_status {
	my @status = ( &human_type() );
	if (&is_resquash_type()) {
		my $human = &human_threshold($threshold);
		$status[0] .= (' ' x (5 - length($human))) . "(${human})"
			unless ($verbose);
		my $thr = &threshold_dir(($threshold > 0) ? $threshold : 0);
		if ($thr eq '') {
			&error('no CHANGES dir: ' .
				&get_abspath('CHANGES', $force, 1));
			return ''
		}
		state %msg;
		%msg = (
			UNMODIFIED => 'unmodified',
			RESQUASH => 'will resquash modifications',
			THRESHOLD => 'modified, but will not resquash',
			KILL => 'will kill modifications',
			KILLEMPTY => 'unmodified (kill)',
			KILLNEGEMPTY => 'unmodified (kill-or-resquash)'
		) unless (%msg);
		if ($threshold < 0) {
			push(@status, $msg{($thr == 0) ? 'UNMODIFIED' :
				(($threshold == -1) ? 'THRESHOLD' : 'RESQUASH')})
		} elsif ($thr == 0) {
			push(@status, $msg{($kill == 0) ? 'UNMODIFIED' :
				(($kill > 0) ? 'KILLEMPTY' : 'KILLNEGEMPTY')})
		} elsif ($thr > 0) {
			push(@status, $msg{($kill > 0) ? 'KILL' : 'RESQUASH'})
		} else {  # ($thr < 0)
			push(@status, $msg{$kill ? 'KILL' : 'THRESHOLD'})
		}
		push(@status, 'THRESHOLD: ' .
			(($verbose > 1) ? "$threshold" : $human)) if ($verbose)
	}
	return &print_status(\@status) unless ($verbose > 1);
	my $dir = &get_abspath('DIR', $force, 1);
	push(@status, 'DIR: ' . $dir) if (&is_abspath($dir));
	my $readonly = &get_abspath('READONLY', $force, '');
	push(@status, 'READONLY: ' . $readonly) if (&is_nonempty($readonly));
	push(@status, 'CHANGES: ' . &get_abspath('CHANGES', $force, 1))
		if (&is_valid_changes($force));
	push(@status, 'WORKDIR: ' . &get_abspath('WORKDIR', $force, 1))
		if (&is_valid_workdir($force));
	my $file = &get_abspath('FILE', $force);
	if (&is_abspath($file)) {
		push(@status, 'FILE: ' . $file);
		if (-f $file) {
			my $mtime = &local_mtime($file);
			push(@status, 'mtime: ' . $mtime)
				if (&is_nonempty($mtime))
		}
	}
	push(@status, "TEMPDIR: $tempdir") if (&is_abspath($tempdir));
	push(@status, "BACKUP: $backup") if (&is_nonempty($backup));
	&mksquashfs_options(\my @options);
	push(@status, &shell_quote_best_effort('mksquashfs-options:',
		@options));
	push(@status, &shell_quote_best_effort('tar-options:',
		&tar_options()));
	push(@status, &shell_quote_best_effort('tar2sqfs-options:',
		&tar2sqfs_options()));
	my $chmod = &get_chmod();
	push(@status, 'CHMOD: ' . (($chmod eq '') ? 'unchanged (0400)' :
		sprintf('%#o', $chmod)));
	my ($uid, $gid) = &get_chown();
	push(@status, 'CHOWN: ' .
		(defined($uid) ? "$uid:$gid" : 'unchanged (0:0)'));
	my $chmod_dir = &get_chmod('CHMOD_DIR');
	push(@status, 'CHMOD_DIR: ' . (($chmod_dir eq '') ? 'unchanged' :
		sprintf('%#o', $chmod_dir)));
	my ($uid_dir, $gid_dir) = &get_chown('CHOWN_DIR');
	push(@status, 'CHOWN_DIR: ' .
		(defined($uid_dir) ? "$uid_dir:$gid_dir" : 'unchanged'));
	&print_status(\@status)
}

sub cmd_print_tag {
	&do_print($tag)
}

sub cmd_print_dir {
	&do_print(&get_abspath('DIR', $force, 1))
}

sub cmd_print_readonly {
	&do_print(&get_abspath('READONLY', $force, ''))
}

sub cmd_print_changes {
	&do_print(&is_valid_changes($force) ?
		&get_abspath('CHANGES', $force, 1) : undef)
}

sub cmd_print_workdir {
	&do_print(&is_valid_workdir($force) ?
		&get_abspath('WORKDIR', $force, 1) : undef)
}

sub cmd_print_file {
	&do_print(&get_abspath('FILE', $force))
}

sub cmd_print_mtime {
	&do_print(&local_mtime(&get_abspath('FILE', $force)) // '')
}

sub cmd_print_type {
	&do_print($current->{'TYPE'} // '')
}

sub cmd_print_squashtype {
	&do_print($current->{'MOUNT_RO'} // '')
}

sub cmd_print_new {
	return &do_print(undef) unless (&is_valid_changes($force));
	my ($will_squash, undef) = &check_squash(0, '');
	my $result = $will_squash ? '1' : '';
	&do_print($quiet ? $result : ('NEW: ' . $result))
}

sub cmd_print_will_squash {
	return &do_print(undef) unless (&is_valid_changes($force));
	my ($will_squash, undef) = &check_squash($threshold, $kill);
	my $result = $will_squash ? '1' : '';
	&do_print($quiet ? $result : ('WILL_SQUASH: ' . $result))
}

sub cmd_print_threshold {
	&do_print(($verbose || $quiet) ?
		"$threshold" : &human_threshold($threshold))
}

sub cmd_print_kill {
	&do_print($quiet ? $kill : ('KILL: ' . $kill));
}

#
# Functions
#

# The main start/mount function:

sub mount_main {
	my ($start_cmd, $skip_ro_mounting) = @_;
	return '' if (&error_if_mounted());
	my $squashfile = &get_abspath('FILE', 1);
	my $first_create = $start_cmd;
	if (-f $squashfile) {
		$first_create = ''
	} elsif (!$first_create) {
		&error("squash-file $squashfile not found");
		return ''
	}
	return '' unless (&create_dir('DIR', 1));
	my $dir = $current->{'DIR'};
	return '' unless (-d $dir);
	if ($first_create) {
		return '' unless (&first_create($squashfile, $dir))
	}
	my $ro_stat = &create_dir('READONLY', '');
	return '' unless ($ro_stat);
	&info('mounting...') unless ($quiet);
	return '' unless (&run_hook($CFG::before_mount, '$before_mount'));
	if ($ro_stat < 0) {
		my $squashtype = &mount_squash($squashfile, $dir);
		return '' unless (&is_nonempty($squashtype));
		$current->{'MOUNT_RO'} = $squashtype;
		$current->{'TYPE'} = 'readonly';
		delete($current->{'CHANGES'});
		delete($current->{'WORKDIR'});
		return 1
	}
	my $dir_ro = $current->{'READONLY'};
	my $ret = 1;
	unless ($skip_ro_mounting // '') {
		my $mount_ro = 1;
		if (&is_nonempty($current->{'MOUNT_RO'})) {
			&warning("have mounted READONLY $dir_ro")
				unless ($quiet > 1);
			$mount_ro = '' unless ($ignore_state)
		}
		if ($mount_ro) {
			my $squashtype = &mount_squash($squashfile, $dir_ro);
			unless (&is_nonempty($squashtype)) {
				return '' unless ($ignore_state && $force);
				&warning('presuming mount was succesful due to -fI') unless ($quiet > 1);
				$squashtype = 'unknown';
				$ret = ''
			}
			$current->{'MOUNT_RO'} = $squashtype
		}
	}
	my $type = &mount_rw($dir_ro, $dir);
	return '' unless (defined($type));
	$current->{'TYPE'} = $type;
	if ($ret) {
		&set_permissions($dir, 1);
		return '' unless (&run_hook($CFG::after_mount, '$after_mount'))
	}
	return $ret unless ($start_cmd && $ret && (!$first_create) &&
		(($user_config->{'RESQUASH_ON_START'}) // $resquash_on_start));
	$ret = &remount_main();
	$current->{'THRESHOLD'} = -1;
	$ret
}

# Call to lsof if necessary:

sub lsof {
	my ($dir, $readonly) = @_;
	return 1 unless (&is_abspath($dir));
	return 1 unless (&which_store(\$lsof_bin, 'lsof'));
	return 1 if (&my_system(2, \$lsof_bin, 'lsof', '--', $dir) == 1);
	my $loclsof = ($readonly ? $current_lsof_ro : $current_lsof );
	if ($loclsof && ($loclsof > 0)) {
		&error('umount skipped: dir in use: ' . $dir,
			'(this test can be skipped with ' .
			($readonly ? '--lsof-ro=0' :  '--lsof=0') . ')')
	} elsif ($verbose) {
		&warning('bad report of lsof ' . $dir)
	}
	''
}

# The main umount function.
# $will_squash and $will_remove will be calculated if they are not passed
# as the second or third argument, respectively.

sub umount_main {
	my $stop_cmd = (shift() // '');
	my $type = $current->{'TYPE'};
	if ($current_lsof_ro && $current_lsof_ro > 0) {
		if (&is_nonempty($current->{'MOUNT_RO'})) {
			return '' unless (&lsof(&get_abspath('READONLY'), 1))
		}
	}
	return(&run_hook($CFG::before_umount, '$before_umount') &&
		&umount_readonly($stop_cmd, $quiet ? '' : 'umounting READONLY') &&
		&run_hook($CFG::after_umount, '$after_umount'))
		unless ($ignore_state || &is_nonempty($type));
	my ($will_squash, $will_remove) = @_;
	($will_squash, $will_remove) = &check_squash($threshold, $kill)
		unless (defined($will_squash) && defined($will_remove));
	my $created = '';
	my $tempfile;
	my $dir = &get_abspath('DIR');
	$dir = undef unless (&is_abspath($dir));
	if ($current_lsof && $current_lsof > 0) {
		return '' unless (&lsof($dir, ''));
	}
	if ($will_squash && defined($dir)) {
		&info('squashing (this may take a while)') unless ($quiet);
		if (&is_abspath($tempdir)) {
			$tempfile = File::Temp->new(DIR => $tempdir)
		} else {
			$tempfile = File::Temp->new();
		}
		return '' unless (&createsquashfs($tempfile->filename, $dir));
		$created = 1
	}
	&info('umounting...') unless ($quiet);
	my $ret = 1;
	my $message = '';
	my $umount_ret = (defined($dir) &&
		&run_hook($CFG::before_umount, '$before_umount'));
	if ($umount_ret) {
		$umount_ret = &umount_dir($dir, '', &is_fuse_type());
		$umount_ret = '' unless (&run_hook($CFG::after_umount, '$after_umount'))
	}
	if ($umount_ret) {
		&rmdir_recurse($dir, ($user_config->{'RM_DIR'} // $rm_dir))
			if ($stop_cmd)
	} else {
		&error('cannot determine DIR') unless (defined($dir));
		return '' unless ($ignore_state && $force);
		&warning('presuming umount was succesful due to -fI') unless ($quiet > 1);
		$ret = '';
		$message = 'umounting READONLY' unless ($quiet)
	}
	if (($type eq 'overlay') || ($type eq 'overlayfs')) {
		my $workdir = &get_abspath('WORKDIR');
		if (&is_abspath($workdir) && (-d $workdir)) {
			&info('cleaning workdir...') unless ($quiet);
			if (&clean_directory($workdir)) {
				&rmdir_recurse($workdir, ($user_config->{'RM_WORKDIR'} // $rm_workdir))
					if ($stop_cmd)
			} else {
				$ret = ''
			}
		}
	}
	delete($current->{'TYPE'});
	&reset_main(!$quiet) if ($reset);
	$ret = '' unless (&umount_readonly($stop_cmd, $message));
	if ($created) {
		my $squashfile = &get_abspath('FILE', 1);
		if (&is_nonempty($backup)) {
			my $file = (&is_abspath($backup) ? $backup :
				$squashfile . $backup);
			&info("$squashfile -> $file") unless ($quiet);
			unlink($file);
			unless (File::Copy::move($squashfile, $file)) {
				&error("failed moving $squashfile to $file");
				return ''
			}
		}
		&info('tempfile' . ($verbose ?
			" \($tempfile\)" : '') . " \-\> $squashfile")
			unless ($quiet);
		unlink($squashfile);
		$tempfile->unlink_on_destroy('');
		unless (File::Copy::move($tempfile->filename, $squashfile)) {
			&error("failed moving tempfile to $squashfile");
			return ''
		}
		&set_permissions($squashfile)
	}
	return $ret unless ($will_remove);
	my $changes = &get_abspath('CHANGES');
	if (&is_abspath($changes) && (-d $changes)) {
		&title("$tag cleaning");
		&info('cleaning changes...') unless ($quiet);
		if (&clean_directory($changes)) {
			&rmdir_recurse($changes, ($user_config->{'RM_CHANGES'} // $rm_changes))
				if ($stop_cmd)
		} else {
			$ret = ''
		}
	}
	$ret
}

# The main remount function

sub remount_main {
	return '' if (&error_unless_mounted());
	my ($will_squash, $will_remove) = (1);
	($will_squash, $will_remove) = &check_squash($threshold, $kill)
		if (&is_nonempty($current->{'TYPE'}));
	unless ($force || $will_squash || ($will_remove > 0)) {
		&info('remounting appears unnecessary');
		return 1
	}
	&title("$tag remount") if ($printed_title);
	return '' unless (&umount_main('', $will_squash, $will_remove));
	&mount_main('')
}

# Umount readonly directory if mounted, and remove it if first arg is true.
# If umounting really happens, print second argument.

sub umount_readonly {
	return 1 unless ($ignore_state || &is_nonempty($current->{'MOUNT_RO'}));
	my $stop_cmd = (shift() // '');
	my $message = (shift() // '');
	&info($message) if ($message ne '');
	my $dir_ro = &get_abspath('READONLY');
	return '' unless (&is_abspath($dir_ro) &&
		&umount_dir($dir_ro, 1, &is_squashfuse_type()));
	&rmdir_recurse($dir_ro, ($user_config->{'RM_READONLY'} // $rm_readonly))
		if ($stop_cmd // '');
	delete($current->{'MOUNT_RO'});
	1
}

# Return type in a human-readable form

sub human_type {
	my $type = $current->{'TYPE'};
	my $squashtype = $current->{'MOUNT_RO'};
	if (&is_nonempty($type)) {
		return (&is_nonempty($squashtype) ? $type . '/' . $squashtype :
			$type)
	}
	&is_nonempty($squashtype) ? $squashtype : 'not mounted'
}

# The main reset function.

sub reset_main {
	my ($message) = @_;
	&info('resetting configuration') if ($message);
	&fill_current(1)
}

# print an error and return 1 if not at least halfmounted and not -I

sub error_unless_mounted {
	unless (&is_nonempty($current->{'TYPE'})
		|| &is_nonempty($current->{'MOUNT_RO'})) {
		unless ($ignore_state) {
			&error('not mounted');
			return 1
		}
		&warning('apparently not mounted; ignoring due to -I')
	}
	''
}

# print an error and return 1 if mounted and not -I

sub error_if_mounted {
	if (&is_nonempty($current->{'TYPE'})) {
		unless ($ignore_state) {
			&error('already mounted');
			return 1
		}
		&warning('apparently mounted; ignoring due to -I')
	}
	''
}

# This function is called for the first creation of the squash-file

sub first_create {
	my ($squashfile, $dir) = @_;
	&info('It seems this is mounted for the first time:',
		"The squash-file $squashfile does not exist yet;",
		"it will be initialized now from $dir") unless ($quiet);
	return '' unless (&createsquashfs($squashfile, $dir));
	&set_permissions($squashfile);
	# Sanity check: do not wipe if e.g. kernel has no squashfs support
	my $success = 1; {
		my $tmp = File::Temp::newdir();
		my $name = $tmp->dirname;
		my $squashtype = &mount_squash($squashfile, $name);
		if (&is_nonempty($squashtype)) {
			$success = '' unless (&umount_dir($name, 1, &is_squashfuse_type($squashtype)))
		} else {
			$success = ''
		}
	}
	unless ($success) {
		&error('failed to mount generated squash-file ' . $squashfile,
			'skipping deletion of original DIR ' . $dir);
		return ''
	}
	&info('cleaning original DIR') unless ($quiet);
	&clean_directory($dir)
}

# Chmod and chown according to mount-point defaults

sub set_permissions {
	my $filedir = shift();
	my $dir = shift() // '';
	my $ret = 1;
	my $chmod = &get_chmod($dir ? 'CHMOD_DIR' : undef);
	unless ($chmod eq '') {
		unless (chmod($chmod, $filedir)) {
			my $octal = sprintf('%#o', $chmod);
			&warning("chmod $octal $filedir failed");
			$ret = ''
		}
	}
	my ($uid, $gid) = &get_chown($dir ? 'CHOWN_DIR' : undef);
	return $ret unless (defined($uid));
	unless (chown($uid, $gid, $filedir)) {
		&warning("chown $uid:$gid $filedir failed");
		$ret = ''
	}
	$ret
}

# Return sanitized CHMOD value or empty

sub get_chmod {
	my $chmod = $user_config->{$_[0] // 'CHMOD'};
	return (defined($_[0]) ? '' : 0644) unless (defined($chmod));
	$chmod
}

# Return CHOWN values as array.

sub get_chown {
	my $chown = $user_config->{$_[0] // 'CHOWN'};
	my ($uid, $gid) = (undef, undef);
	return (undef, undef) unless (defined($chown));
	if (ref($chown) eq 'ARRAY') {
		return (undef, undef) unless (@$chown);
		($uid, $gid) = @$chown
	} else {
		return (undef, undef) if ($chown eq '');
		($uid, $gid) = split(qr{\D}, $chown)
	}
	$uid = -1 unless (defined($uid) && ($uid =~ m{^\d+$}));
	$gid = -1 unless (defined($gid) && ($gid =~ m{^\d+$}));
	return (undef, undef) if (($uid == -1) && ($gid == -1));
	($uid, $gid)
}

# The main function to mount read-writable. Returns type or undef

sub mount_rw {
	my ($ro, $rw) = @_;
	return undef unless (&create_dir('CHANGES', 1));
	my $changes = $current->{'CHANGES'};
	for my $i ($ro, $rw, $changes) {
		unless (-d $i) {
			&error("no directory $i");
			return undef
		}
	}
	for my $i (@order) {
		my $probemod = (($i =~ m{\!}) ? (($i =~ m{\!\!}) ? '' : -1) : 1);
		my $check_bin = ($i =~ m{\#});
		my $check_gz = (($i =~ m{\?}) ? (($i =~ m{\?\?}) ? -1 : 1) : '');
		if ($i =~ m{fuse}i && $i =~ m{over}i) {
			return 'fuse-overlayfs' if (&mount_fuse_overlayfs($probemod, $check_gz, $check_bin, $ro, $rw, $changes))
		} elsif ($i =~ m{overlayfs}i) {
			my $type = &mount_overlayfs($probemod, $check_gz, $check_bin, $ro, $rw, $changes);
			return $type if ($type ne '')
		} elsif ($i =~ m{overlay}i) {
			return 'overlay' if (&mount_overlay($probemod, $check_gz, $check_bin, $ro, $rw, $changes))
		} elsif ($i =~ m{aufs}i) {
			return 'aufs' if (&mount_aufs($probemod, $check_gz, $check_bin, $ro, $rw, $changes))
		} elsif ($i =~ m{fuse}i) {
			return 'unionfs-fuse' if (&mount_unionfs_fuse($probemod, $check_gz, $check_bin, $ro, $rw, $changes))
		} elsif ($i =~ m{funion}i) {
			return 'funionfs' if (&mount_funionfs($probemod, $check_gz, $check_bin, $ro, $rw, $changes))
		} elsif ($i =~ m{union}i) {
			return 'unionfs' if (&mount_unionfs($probemod, $check_gz, $check_bin, $ro, $rw, $changes))
		} else {  # ($i =~ m{bind}i)
			return (&mount_bind($ro, $rw) ? 'bind' : undef)
		}
	}
	&error('fallback to mount --bind');
	&mount_bind($ro, $rw) ? 'bind' : undef
}

# Mount with overlay.

sub mount_overlay {
	my ($probemod, $check_gz, $check_bin, $ro, $rw, $changes) = @_;
	return '' unless (&kernelprobe($probemod, $check_gz, 'overlay'));
	return '' if ($check_bin && !&which_store(\$mount, 'mount'));
	my $workdir = &create_workdir();
	return '' if ($workdir eq '');
	&push_ref(\my @options, $user_config->{'MOUNT_OVERLAY'},
		['-o', 'noatime', '-o', 'index=off']);
	push(@options, '-v') if ($verbose > 3);
	return 1 if (&my_system('', \$mount, 'mount', '-t', 'overlay', @options,
		'-o', "upperdir\=${changes}", '-o', "lowerdir\=${ro}",
		'-o', "workdir\=${workdir}", '--', 'overlay', $rw) == 0);
	&warning('overlay failed') unless ($quiet > 1);
	''
}

# Mount with overlayfs.
# Returns 'overlayfs', 'overlayfs-obsolete', or '' (failure)

sub mount_overlayfs {
	my ($probemod, $check_gz, $check_bin, $ro, $rw, $changes) = @_;
	return '' unless (&kernelprobe($probemod, $check_gz, 'overlayfs'));
	return '' if ($check_bin && !&which_store(\$mount, 'mount'));
	&push_ref(\my @options, $user_config->{'MOUNT_OVERLAYFS'},
		['-o', 'noatime']);
	push(@options, '-v') if ($verbose > 3);
	my @systemargs1 = ('', \$mount, 'mount', '-t', 'overlayfs', @options,
		'-o', "upperdir\=${changes}", '-o', "lowerdir\=${ro}");
	my @systemargs2 = ('--', 'overlayfs', $rw);
	if (&is_nonempty($CFG::obsolete_overlayfs)) {
		return 'overlayfs-obsolete'
			if (&my_system(@systemargs1, @systemargs2) == 0)
	}
	unless (($CFG::obsolete_overlayfs // '') eq 'force') {
		my $workdir = &create_workdir();
		return 'overlayfs' if (($workdir ne '') &&
			(&my_system(@systemargs1, '-o', "workdir\=${workdir}",
				@systemargs2) == 0))
	}
	if (($CFG::obsolete_overlayfs // 1) eq '') {
		return 'overlayfs-obsolete'
			if (&my_system(@systemargs1, @systemargs2) == 0)
	}
	&warning('overlayfs failed') unless ($quiet > 1);
	''
}

# Return $workdir, creating it if necessary. Return '' if not successful.

sub create_workdir {
	my $success = &create_dir('WORKDIR', 1);
	my $workdir = (($success && ($success > 0)) ? $current->{'WORKDIR'} : '');
	unless (&is_abspath($workdir)) {
		&error('failed to create workdir');
		return ''
	}
	return $workdir if (-d $workdir);
	&error("no directory $workdir");
	''
}

# Mount with aufs:

sub mount_aufs {
	my ($probemod, $check_gz, $check_bin, $ro, $rw, $changes) = @_;
	return '' unless (&kernelprobe($probemod, $check_gz, 'aufs'));
	return '' if ($check_bin && !&which_store(\$mount, 'mount'));
	&push_ref(\my @options, $user_config->{'MOUNT_AUFS'},
		['-o', 'noatime']);
	push(@options, '-v') if ($verbose > 3);
	$ro =~ s{([=:])}{\\$1}g;
	$changes =~ s{([=:])}{\\$1}g;
	return 1 if (&my_system('', \$mount, 'mount', '-t', 'aufs', @options,
		'-o', "br\:${changes}\=rw\:${ro}\=rr", '--', 'aufs', $rw) == 0);
	&warning('aufs failed') unless ($quiet > 1);
	''
}

# Mount with fuse-overlayfs

sub mount_fuse_overlayfs {
	my ($probemod, $check_gz, $check_bin, $ro, $rw, $changes) = @_;
	&push_ref(\my @options, $user_config->{'MOUNT_FUSE_OVERLAYFS'},
		[@allow_other, '-o', 'use_ino', '-o', 'nonempty',
		'-o', 'noatime']);
	my $workdir = &create_workdir();
	return '' if ($workdir eq '');
	my $tool = 'fuse-overlayfs';
	unless (&which_store(\$fuse_overlayfs, $tool)) {
		return '' if ($check_bin)
	}
	return '' unless (&kernelprobe($probemod, $check_gz, 'fuse'));
	return 1 if (&my_system('', \$fuse_overlayfs, $tool, @options,
		'-o', "upperdir\=${changes}", '-o', "lowerdir\=${ro}",
		'-o', "workdir\=${workdir}", # '--', # -- breaks fuse-overlayfs
		$rw) == 0);
	&warning('fuse-overlayfs failed') unless ($quiet > 1);
	''
}

# Mount with unionfs-fuse

sub mount_unionfs_fuse {
	my ($probemod, $check_gz, $check_bin, $ro, $rw, $changes) = @_;
	&push_ref(\my @options, $user_config->{'MOUNT_UNIONFS_FUSE'},
		['-o', 'cow', @allow_other, '-o', 'use_ino', '-o', 'nonempty',
		'-o', 'noatime', '-o', 'hide_meta_files']);
	$ro =~ s{([=:])}{\\$1}g;
	$changes =~ s{([=:])}{\\$1}g;
	my @tools = ('unionfs', 'unionfs-fuse');
	unless (&which_store(\$unionfs_fuse, @tools)) {
		return '' if ($check_bin)
	}
	return '' unless (&kernelprobe($probemod, $check_gz, 'fuse'));
	push(@options, "${changes}\=RW\:${ro}\=RO", $rw);
	my $sys = &my_system('', \$unionfs_fuse, [ @tools ], @options);
	return 1 if ($sys == 0);
	if (($sys < 0) && (&which_which() eq '')  # We have no which
		&& ($unionfs_fuse eq $tools[0])) {
		if (&my_system('', \my $tool, $tools[1], @options) == 0) {
			$unionfs_fuse = $tool;  # remember: this is ok
			return 1
		}
	}
	&warning('unionfs-fuse failed') unless ($quiet > 1);
	''
}

# Mount with unionfs

sub mount_unionfs {
	my ($probemod, $check_gz, $check_bin, $ro, $rw, $changes) = @_;
	return '' unless (&kernelprobe($probemod, $check_gz, 'unionfs'));
	return '' if ($check_bin && !&which_store(\$mount, 'mount'));
	&push_ref(\my @options, $user_config->{'MOUNT_UNIONFS'},
		['-o', 'noatime']);
	push(@options, '-v') if ($verbose > 3);
	$ro =~ s{([=:])}{\\$1}g;
	$changes =~ s{([=:])}{\\$1}g;
	return 1 if (&my_system('', \$mount, 'mount', '-t', 'unionfs', @options,
		'-o', "dirs\=${changes}\=rw\:${ro}\=ro", '--', 'unionfs', $rw) == 0);
	&warning('unionfs failed') unless ($quiet > 1);
	''
}

# Mount with funionfs

sub mount_funionfs {
	my ($probemod, $check_gz, $check_bin, $ro, $rw, $changes) = @_;
	return '' if ($check_bin && !&which_store(\$funionfs, 'funionfs'));
	return '' unless (&kernelprobe($probemod, $check_gz, 'fuse'));
	&push_ref(\my @options, $user_config->{'MOUNT_FUNIONFS'},
		[@allow_other, '-o', 'nonempty']);
	$ro =~ s{\=}{\\\=}g;
	return 1 if (&my_system('', \$funionfs, 'funionfs', $changes, $rw, @options,
		'-o', "dirs\=${ro}\=ro") == 0);
	&warning('funionfs failed') unless ($quiet > 1);
	''
}

# Mount with bind:

sub mount_bind {
	my ($from, $to) = @_;
	my @options = ('--bind');
	push(@options, '-v') if ($verbose > 3);
	return 1 if (&my_system('', \$mount, 'mount', @options, '--', $from, $to) == 0);
	&error('mount --bind failed');
	''
}

# Mount the squash-file readonly:

sub mount_squash {
	my ($squashfile, $dir) = @_;
	unless (-d $dir) {
		&error("no directory $dir");
		return ''
	}
	for my $i (@squashorder) {
		my $probemod = (($i =~ m{\!}) ? (($i =~ m{\!\!}) ? '' : -1) : 1);
		my $check_bin = ($i =~ m{\#});
		my $check_gz = (($i =~ m{\?}) ? (($i =~ m{\?\?}) ? -1 : 1) : '');
		if ($i =~ m{fuse}i) {
			return 'squashfuse' if (&mount_squashfuse($probemod, $check_gz, $check_bin, $squashfile, $dir))
		} else {
			return 'squashfs' if (&mount_squashfs($probemod, $check_gz, $check_bin, $squashfile, $dir))
		}
	}
	&error('failed to mount squash-file');
	''
}

# Mount with squashfs

sub mount_squashfs {
	my ($probemod, $check_gz, $check_bin, $squashfile, $dir) = @_;
	return '' unless (&kernelprobe($probemod, $check_gz, 'squashfs'));
	if ($modprobe_loop) {
		return '' unless (&kernelprobe($probemod, $check_gz, 'loop'))
	}
	return '' if ($check_bin && !&which_store(\$mount, 'mount'));
	my @options = ('-t', 'squashfs', '-o', 'loop,ro,noatime');
	push(@options, '-v') if ($verbose > 3);
	return 1 if (&my_system('', \$mount, 'mount', @options,
		'--', $squashfile, $dir) == 0);
	&warning('squashfs failed') unless ($quiet > 1);
	''
}

# Mount with squashfuse

sub mount_squashfuse {
	my ($probemod, $check_gz, $check_bin, $squashfile, $dir) = @_;
	&push_ref(\my @options, $user_config->{'MOUNT_SQUASHFUSE'},
		[@allow_other, '-o', 'nonempty']);
	push(@options,
		# '--',  # squashfuse does not support '--'
		$squashfile, $dir);
	my @tools = ($squashfuse_ll ? ('squashfuse_ll') : ());
	push(@tools, 'squashfuse');
	unless (&which_store(\$squashfuse, @tools)) {
		return '' if ($check_bin)
	}
	return '' unless (&kernelprobe($probemod, $check_gz, 'fuse'));
	my $sys = &my_system('', \$squashfuse, [ @tools ], @options);
	return 1 if ($sys == 0);
	if ($squashfuse_ll && ($sys < 0)
		&& (&which_which() eq '')  # We have no which
		&& ($squashfuse eq $tools[0])) {
		my $tool;
		if (&my_system('', \my $tool, $tools[1], @options) == 0) {
			$squashfuse = $tool;  # remember: this is ok
			return 1
		}
	}
	&warning('squashfuse failed') unless ($quiet > 1);
	''
}

# Create the squash-file:

sub createsquashfs {
	my ($squashfile, $dir) = @_;
	unless (-d $dir) {
		&error("no directory $dir");
		return ''
	}
	&title("$tag squashing");
	my @parent = &split_dir($squashfile);
	pop(@parent);
	my $parent = &cat_dir(@parent);
	if (($parent ne '') && !(-d $parent)) {
		return '' unless (&make_directory($parent))
	}
	my $bad = '';
	my $unavailable;
	if ($use_tar2sqfs) {
		$unavailable = &unavailable_tar2sqfs();
		if ($unavailable ne '') {
			if (&which_store(\$mksquashfs, 'mksquashfs')) {
				$use_tar2sqfs = '';
				&warning($unavailable .
				' not available; using --no-tar')
			} else {
				$bad = 1
			}
		}
	} elsif (!&which_store(\$mksquashfs, 'mksquashfs')) {
		$unavailable = &unavailable_tar2sqfs();
		if ($unavailable eq '') {
			$use_tar2sqfs = 1;
			&warning('mksquashfs not available; using --tar',
				$quiet ?
				'To make this the default: $tar2sqfs = 1;' : ())
				unless ($quiet > 1)
		} else {
			$bad = 1;
		}
	}
	if ($bad) {
		&error('Neither mksquashfs nor ' . $unavailable . ' are in $PATH');
		return ''
	}
	$use_tar2sqfs ? &tar2sqfs($squashfile, $dir)
		: &mksquashfs($squashfile, $dir)
}

sub unavailable_tar2sqfs {
	&which_store(\$tar, 'tar', 'gtar', 'star') ?
		(&which_store(\$tar2sqfs, 'tar2sqfs') ? '' : 'tar2sqfs')
		: '{,g,s}tar'
}

sub mksquashfs {
	my ($squashfile, $dir) = @_;
	my $redirect = &mksquashfs_options(\my @options);
	my $oldout = undef;
	my $ret = (&my_system($redirect, \$mksquashfs, 'mksquashfs', $dir, $squashfile, @options) == 0);
	&error($verbose ? 'failed: ' . &shell_quote_best_effort($mksquashfs, $dir, $squashfile, @options)
		: 'mksquashfs failed') unless ($ret);
	$ret
}

sub tar2sqfs {
	my ($squashfile, $dir) = @_;
	my $cd = &shell_quote_best_effort('cd', '--', $dir) . ' && ';
	my @tar = ('-c', &tar_options(), '.');
	my $tarcmd = &shell_quote_best_effort($tar, @tar) . ' | ';
	my @tar2sqfs = (&tar2sqfs_options(), '--', $squashfile);
	my $tar2sqfscmd = &shell_quote_best_effort($tar2sqfs, @tar2sqfs);
	my $ret = (&my_system_cmd('', $cd . $tarcmd . $tar2sqfscmd) == 0);
	&error($verbose ? 'failed: ' . $cd .
		&shell_quote_best_effort((File::Spec->splitpath($tar))[2],
			@tar) . ' | ' .
			&shell_quote_best_effort('tar2sqfs', @tar2sqfs)
		: 'tar->tar2sqfs failed') unless ($ret);
	$ret
}

# Set array of options for mksquashfs and return redirection for &my_system()
# Defines/uses $mksquash_symbols for the calculation, using $mksquash_verbose.

sub mksquashfs_options {
	my ($options) = @_;
	@$options = ('-noappend');
	push(@$options, '-processors', $processors) if ($processors ne '');
	push(@$options, '-mem', $mem) if ($mem ne '');
	$mksquash_symbols = &calc_mksquash_symbols($mksquash_verbose)
		unless (defined($mksquash_symbols));
	push(@$options, '-quiet') if (($verbose <= 3) &&
		defined($mksquash_symbols->{'q'}));
	push(@$options, '-no-progress') if (defined($mksquash_symbols->{'n'}));
	push(@$options, '-info') if (($verbose > 3) &&
		defined($mksquash_symbols->{'i'}));
	push(@$options, '-progress') if (defined($mksquash_symbols->{'p'}));
	push(@$options, '-always-use-fragments') if (&is_nonempty($user_config->{'DEFAULT_FRAGMENTS'}));
	my $comp = (defined($compression) ? lc($compression) : 'zstd');
	my $compopt = $user_config->{'COMPOPT_' . uc($comp)};
	unless (defined($compopt)) {
		$compopt = ['-Xcompression-level', '22'] if ($comp eq 'zstd');
		$compopt = '-Xhc' if ($comp eq 'lz4')
	}
	push(@$options, '-comp', $comp) if ($comp ne '');
	&push_ref($options, $compopt, undef);
	&push_ref($options, $user_config->{'MKSQUASHFS'}, undef);
	defined($mksquash_symbols->{'r'})
}

# Return $mksquash_symbols according to $mksquash_verbose argument:

sub calc_mksquash_symbols {
	my $squash_verbose = (shift() // 'q?n-n+!');
	my $squash_symbols = {};
	while($squash_verbose =~ s{([inpqr])([12\-\+\?\!]*)}{}i) {
		my ($symbol, $flags) = ($1, $2);
		if ($flags =~ m{[1\-]}) {
			next if (((!$stdoutterm) && ($flags =~ m{1})) ||
				($stdoutterm && ($flags =~ m{\-})))
		}
		if ($flags =~ m{[2\+]}) {
			$stderrterm //= ((-t STDERR) // '');
			next if (((!$stderrterm) && ($flags =~ m{2})) ||
				($stderrterm && ($flags =~ m{\+})))
		}
		if ($flags =~ m{[\?\!]}) {
			&set_know_quiet() unless (defined($know_quiet));
			next if (((!$know_quiet) && ($flags =~ m{\?})) ||
				($know_quiet && ($flags =~ m{\!})))
		}
		if ($symbol =~ m{[[:upper:]]}) {
			delete($squash_symbols->{lc($symbol)})
		} else {
			$squash_symbols->{$symbol} = 1
		}
	}
	$squash_symbols
}

# Set array of options for tar:

sub tar_options {
	my @options = ();
	&push_ref(\@options, $user_config->{'TAR'} // '--numeric-owner', undef);
	(@options)
}

# Set array of options for tar2sqfs:

sub tar2sqfs_options {
	my @options = ('-f');
	my $comp = (defined($compression) ? lc($compression) : 'zstd');
	my $compextra = $user_config->{'COMPEXTRA_' . uc($comp)};
	unless (defined($compextra)) {
		$compextra = 'level=22' if ($comp eq 'zstd');
		$compextra = 'hc' if ($comp eq 'lz4')
	}
	push(@options, '-c', $comp) if ($comp ne '');
	if (defined($compextra)) {
		$compextra = join(',', $compextra) if ($compextra eq 'ARRAY');
		&push_ref(\@options, ['-X', $compextra], undef)
			if ($compextra ne '')
	}
	&push_ref(\@options, $user_config->{'TAR2SQFS'}, '-q');
	(@options)
}

# Set $know_quiet:

sub set_know_quiet {
	$know_quiet = '';
	open(my $fh, 'mksquashfs 2>&1 |') || return;
	while(<$fh>) {
		$know_quiet = 1 if (m{\-quiet})
	}
	close($fh)
}

# Umount the directory, possibly lazily and/or checking with lsof first.
# $readonly: Umount READONLY
# $fuse: Umount using fusermount -u; try both if undefined

sub umount_dir {
	my ($dir, $readonly, $fuse) = @_;
	my @uopt = ();
	if ($fuse // '') {
		my $uopt = $user_config->{$readonly ? 'UMOUNT_RO' : 'UMOUNT'};
		if (defined($uopt)) {
			push(@uopt, ref($uopt eq 'ARRAY') ? @$uopt : $uopt)
		} else {
			push(@uopt, ($readonly ? @CFG::umount_ro : @CFG::umount))
		}
		push(@uopt, '-v') if ($verbose > 3);
	}
	my @fopt = ();
	if ($fuse // 1) {
		my $fopt = $user_config->{$readonly ? 'FUMOUNT_RO' : 'FUMOUNT'};
		if (defined($fopt)) {
			push(@fopt, ref($fopt eq 'ARRAY') ? @$fopt : $fopt)
		} else {
			push(@fopt, ($readonly ? @CFG::fumount_ro : @CFG::fumount))
		}
	}
	my $loclazy = $current_lazy;
	my $loclsof = ($readonly ? $current_lsof_ro : $current_lsof );
	if (($loclsof ne '') && !&lsof($dir, $readonly)) {
		if ($loclsof == 0) {
			$loclazy = 1
		} elsif ($loclsof < 0) {
			$loclazy = -1
		} else {
			return ''
		}
	}
	if ($loclazy >= 0) {
		if ($fuse // 1) {
			return 1 if (&my_system(1, \$fusermount, 'fusermount',
				'-u', @fopt, '--', $dir) == 0)
		}
		unless ($fuse // '') {
			return 1 if (&my_system(1, \$umount, 'umount',
				@uopt, '--', $dir) == 0)
		}
		unless ($loclazy) {
			&error('non-lazy umount failed for ', $dir);
			return ''
		}
		&error('non-lazy umount failed,',
			"using lazy umount of $dir") unless ($quiet > 1)
	}
	if ($fuse // 1) {
		return 1 if (&my_system(1, \$fusermount, 'fusermount',
			'-u', '-z', @fopt, '--', $dir) == 0)
	}
	unless ($fuse // '') {
		return 1 if (&my_system(1, \$umount, 'umount',
			'-l', @uopt, '--', $dir) == 0)
	}
	&error("lazy umount failed for $dir");
	''
}

# Check whether squashing is necessary, taking $current and options into account
# Returns ($will_squash, $will_remove).
# $will_remove = -1 denotes cleaning a presumably empty directory.

sub check_squash {
	my ($threshold, $kill) = @_;
	return ('', 0) unless (&is_resquash_type());
	return (1, 1) if ($threshold == -2);
	return ('', 0) if ($threshold < 0);
	return ('', 1) if ($kill > 0);
	my $thr = &threshold_dir($threshold);
	return ('', 0) if ($thr eq '');
	if ($thr == 0) {
		return ('', -1)  # clean "empty" directory
	} elsif ($thr > 0) {
		return (1, 1)  # squash and clean nonempty directory
	}
	('', (($kill < 0) ? 1 : 0))  # no squash but possibly kill
}

# Execute modprobe for the argument

sub my_modprobe {
	my ($module) = @_;
	state %probed;
	$probed{$module} //= (&my_system(2, \$modprobe, 'modprobe',
		(($verbose > 3) ? '-v' : ()), $module) == 0)
}

# use IO::Uncompress::Gunzip () and return whether successful

sub use_gunzip {
	state $gunzip;
	return $gunzip if (defined($gunzip));
	eval {
		require IO::Uncompress::Gunzip
	};
	$gunzip = !$@
}

# Assuming that use_gunzip() has previously been called with success,
# read the kernel configuration. Return 1 on success.

sub read_kernel_config {
	my ($gz) = @_;
	my $buffer;
	return '' unless (IO::Uncompress::Gunzip::gunzip(
		File::Spec->catdir($root, 'proc', 'config.gz') => \$buffer));
	$gz->{'overlay'} = 1 if ($buffer =~ m{^CONFIG_OVERLAY_FS\=[yYmM]}m);
	$gz->{'overlayfs'} = 1 if ($buffer =~ m{^CONFIG_OVERLAYFS_FS\=[yYmM]}m);
	$gz->{'aufs'} = 1 if ($buffer =~ m{^CONFIG_AUFS_FS\=[yYmM]}m);
	$gz->{'unionfs'} = 1 if ($buffer =~ m{^CONFIG_UNION_?FS\=[yYmM]}m);
	$gz->{'fuse'} = 1 if ($buffer =~ m{^CONFIG_FUSE_FS\=[yYmM]}m);
	$gz->{'squashfs'} = 1 if ($buffer =~ m{^CONFIG_SQUASHFS\=[yYmM]}m);
	1
}

# Read /sys/module. Return 1 on success.

sub read_module_config {
	my ($modules) = @_;
	my @dirs = ($root, 'sys', 'module');
	{
		my $dir = File::Spec->catdir(@dirs);
		return '' unless ((-d $dir) && (-r $dir) && (-x $dir))
	}
	for my $m ('overlay', 'overlayfs', 'aufs', 'unionfs', 'fuse', 'squashfs') {
		$modules->{$m} = 1 if (-d File::Spec->catdir(@dirs, $m))
	}
	1
}

# Probe module and/or check the kernel configuration. Return 1 on success

sub kernelprobe {
	my ($probemod, $check_gz, $module) = @_;
	if ($probemod) {
		return 1 if (&my_modprobe($module));
		return '' if (($probemod > 0) && !$check_gz);
	}
	return 1 unless ($check_gz);
	state $modules;
	unless (defined($modules)) {
		$modules = {};
		$modules = '' unless (&read_module_config($modules))
	}
	if (ref($modules eq 'HASH')) {
		return ($modules->{$module} // '')
	}
	state $gz;
	unless (defined($gz)) {
		if (&use_gunzip()) {
			$gz = {};
			$gz = 1 unless (&read_kernel_config($gz))
		} else {
			$gz = ''
		}
	}
	(ref($gz) eq 'HASH') ? ($gz->{$module} // '') : ($check_gz > 0)
}

# The main function to read a configuration file:

# The default config must be parsed before the function
{
	package CFG;
	our $lazy = 1;
	our $lsof = 1;
	our $lsof_ro = 1;
	our $squashfuse_ll = 1;
	our $killpower = [
		'/etc/killpower',
		'/etc/nut/killpower',
		'/etc/nosquash'
	];
	our $mksquash_verbose = 'q?n-n+!';
	our $squash_verbose = undef;
	our $processors = '';
	our $mem = '';
	our $modprobe_loop = 1;
	our $resquash_on_start = '';
	our $rm_rundir = 1;
	our $rm_dir = 0;
	our $rm_changes = 1;
	our $rm_workdir = 1;
	our $rm_readonly = 1;
	our $locking = undef;
	our $tar2sqfs = undef;
	our $obsolete_overlayfs = '';
	our @order = ();
	our @squashorder = ();
	our @mounts = ();
	our @umount = ();
	our @umount_ro = ();
	our @fumount = ();
	our @fumount_ro = ();
	our $command = undef;
	our $storing = undef;
	our $before = undef;
	our $after = undef;
	our $before_mount = undef;
	our $after_mount = undef;
	our $before_umount = undef;
	our $after_umount = undef;
}

our @EXPORT = qw(
	have_stored_data
	standard_mount
	added_hash
	envlibs
	fatal
	error
	errorinfo
	warning
	info
);

sub read_config_file {
	my ($file) = @_;
	$file = &bad_abs_path($file);
	unless (defined($file)) {
		&warning('skipping config file ' . $_[0] . ' (not a valid path)') unless ($verbose);
		return
	}
	if ((-d $file) || !(-r $file)) {
		&warning("skipping config file $file (not a readable file)") if ($verbose);
		return
	}
	&info("reading config file $file") if ($verbose > 2);
	package CFG;
	our $lazy;
	our $lsof;
	our $lsof_ro;
	our $squashfuse_ll;
	our $killpower;
	our $mksquash_verbose;
	our $squash_verbose;
	our $processors;
	our $mem;
	our $modprobe_loop;
	our $resquash_on_start;
	our $rm_rundir;
	our $rm_dir;
	our $rm_changes;
	our $rm_workdir;
	our $rm_readonly;
	our $locking;
	our $tar2sqfs;
	our $obsolete_overlayfs;
	our @order;
	our @squashorder;
	our @mounts;
	our @umount;
	our @umount_ro;
	our @fumount;
	our @fumount_ro;
	our $command;
	our $storing;
	our $before;
	our $after;
	our $before_mount;
	our $after_mount;
	our $before_umount;
	our $after_umount;
	Squashmount->import();
	my $ret = do($file);
	&fatal("failed to parse $file:", "$@") if ($@);
	&fatal("failed to read $file:", "$!") unless (defined($ret));
	&warning("failed to run $file",
		'perhaps the last executed command was not a true expression')
		unless ($ret);
	$ret
}

# Functions exported to the config file

sub have_stored_data($) {
	(-e &settings_file($_[0])) // ''
}

sub added_hash(@) {
	my $a = {};
	for my $i (@_) {
		unless (defined($i) && (ref($i) eq 'HASH')) {
			&warning('wrong argument in added_hash() or standard_mount():',
				'hash reference expected');
			next
		}
		for my $j (keys(%$i)) {
			unless (exists($a->{$j})) {
				$a->{$j} = $i->{$j};
				next
			}
			my $type = ref($i->{$j});
			if ($type eq 'HASH') {
				if (ref($a->{$j}) eq 'HASH') {
					$a->{$j} = &added_hash($a->{$j}, $i->{$j})
				} else {
					$a->{$j} = $i->{$j}
				}
			} elsif ($type eq 'ARRAY') {
				my $source = $i->{$j};
				my $aref = ref($a->{$j});
				if ($aref eq 'ARRAY') {
					my $arrayref = $a->{$j};
					push(@$arrayref, @$source)
				} elsif (($aref eq '') && defined($a->{$j})) {
					$a->{$j} = [ $a->{$j}, @$source ]
				} else {
					$a->{$j} = $source
				}
			} else {
				$a->{$j} = $i->{$j}
			}
		}
	}
	$a
}

sub standard_mount($$@) {
	my $tag = shift();
	my $dir = shift();
	&fatal('first argument of standard_mount() must be a nonempty string or array')
		unless (ref($tag) eq 'ARRAY'
			|| (defined($tag) && (ref(\$tag) eq 'SCALAR') && ($tag ne '')));
	if (ref($dir) eq 'ARRAY') {
		return () if (@$dir == 0);
		return (&standard_mount(ref($tag) eq 'ARRAY' ? $tag->[0] : $tag,
			$dir->[0], @_)) if (@$dir == 1);
		my $format = undef;
		if (ref($tag) eq 'ARRAY') {
			$format = $tag->[1];
			&fatal('tag array in standard_mount must contain nonempty 2nd entry')
				unless (defined($format)
					&& ref(\$format) eq 'SCALAR'
					&& $format ne '')
		}
		my @result = ();
		my $count = 0;
		for my $d (@$dir) {
			++$count;
			push(@result, &standard_mount(defined($format)
				? sprintf($format, $count)
				: $tag . $count,
					$d, @_))
		}
		return @result
	}
	if (ref($tag) eq 'ARRAY') {
		return (&standard_mount($tag->[0], $dir, @_))
	}
	# Checking for -d $dir might be wrong: the config might use
	# this as a flag and not add the result to @mounts later on
	&fatal('error: second argument of standard_mount() should be a directory')
		unless (defined($dir) && (ref(\$dir) eq 'SCALAR') && ($dir ne ''));
	$dir = File::Spec->canonpath($dir);
	&added_hash({
		TAG => $tag,
		DIR => $dir,
		CHANGES => File::Spec->catdir($dir . '.mount', 'changes'),
		READONLY => File::Spec->catdir($dir . '.mount', 'readonly'),
		WORKDIR => File::Spec->catdir($dir . '.mount', 'workdir'),
		FILE => File::Spec->catfile($dir . '.mount',
			((File::Spec->splitpath($dir))[2]) . '.sfs')
	}, @_)
}

sub envlibs($@) {
	my $dirs = shift();
	my $prefix = shift() // '';
	unless(ref($dirs) eq 'ARRAY') {
		&fatal('first argument of envlibs() must be a string or array')
			unless (defined($dirs) && (ref(\$dirs) eq 'SCALAR'));
		$dirs = [$dirs]
	}
	my @result = ();
	for my $file (@$dirs) {
		next unless (-f $file);
		my $fh;
		if (open($fh, '<', $file)) {
			while (my $line = <$fh>) {
				if ($line =~ m{^LDPATH=\"([^\"]*)\"}) {
					my $dir = $prefix . $1;
					push(@result, $dir) if (-d $dir)
				}
			}
		}
		close($fh)
	}
	@result
}

sub calculate_inode() {
	my ($name, $ref) = @_;
	if (defined($$ref)) {
		return (ref($$ref) eq 'ARRAY')
	}
	my ($dev, $ino) = stat($name);
	unless (defined($dev) && defined($ino)) {
		return ($$ref = '')
	}
	$$ref = [ $dev, $ino ];
	1
}

sub handle_bind() {
	return unless (@bind);
	my ($data, $reading) = @_;
	for my $entry ('DIR', 'CHANGES', 'READONLY', 'WORKDIR',
		'FILE', 'BACKUP', 'TEMPDIR') {
		next unless (exists($data->{$entry}));
		my $value = $data->{$entry};
		my @dir = &split_dir($value);
		next unless (&is_abspath($value));
		for my $bind ($reading ? @bind : (reverse(@bind))) {
			my $find = ($reading ? $bind->[0] : $bind->[1]);
			next unless(&starts_with(\@dir, $find));
			my $replace = ($reading ? $bind->[1] : $bind->[0]);
			splice(@dir, 0, scalar(@$find), @$replace);
		}
		$data->{$entry} = &cat_dir(@dir)
	}
	1
}

# Read settings from /run/squashmount:

sub read_settings {
	$current = {};
	my $file = &settings_file();
	return unless (open(my $fh, '<', $file));
	if ($locking) {
		$lockfh = $fh;  # unlock even if we die
		flock($lockfh, Fcntl::LOCK_SH())
	}
	{
		package RUNCFG;
		our %data = ();
		do ($file)
	}
	close($fh) unless (&end_locking());
	$current = &added_hash(\%RUNCFG::data);
	&handle_bind($current, 1)
}

# Write settings to /run/squashmount and unlock:

sub write_settings {
	my $data = &added_hash($current);
	&handle_bind($data);
	my $file = &settings_file();
	my $fh;
	if (defined($lockfh)) {
		$fh = $lockfh;
		unless (seek($fh, 0, Fcntl::SEEK_SET())) {
			&error("cannot seek $file");
			return ''
		}
		unless (truncate($fh, 0)) {
			&error("cannot truncate $file");
			return ''
		}
	} else {
		unless (open($fh, '>', $file)) {
			&error("cannot open $file for writing");
			return ''
		}
		if ($locking) {
			$lockfh = $fh;  # unlock even if we die
			flock($lockfh, Fcntl::LOCK_EX())
		}
	}
	if (&calculate_inode($root, \$rootdata)) {
		$data->{'ROOTDEVICE'} = $rootdata->[0];
		$data->{'ROOTINODE'} = $rootdata->[1];
	}
	my $ret = 1;
	for my $i (sort(keys(%$data))) {
		my $value = $data->{$i};
		next unless (defined($value));
		my $write = "\$data\{\'$i\'\} = ";
		if ($i eq 'THRESHOLD') {
			$write = "\{\n\tuse bigint\;\n\t$write$value\n\}\n"
		} elsif ($value eq '') {
			$write .= "'';\n"
		} elsif ($value =~ m{^\-?\d*$}) {
			$write .= "$value\;\n"
		} else {
			$write .= '"' . quotemeta($value) . "\"\;\n"
		}
		unless (print($fh $write)) {
			&error("cannot write to $file") unless ($ret);
			$ret = ''
		}
	}
	close($fh) unless (&end_locking());
	$ret
}

sub validate_root() {
	return 1 unless(exists($current->{'ROOTDEVICE'}) &&
		exists($current->{'ROOTINODE'}));
	return 1 unless(&calculate_inode($root, \$rootdata));
	return 1 if (&starts_with($rootdata, [
			($current->{'ROOTDEVICE'} // -1),
			($current->{'ROOTINODE'} // -1)
		], 1));
	&error('stored root directory data does not match',
		'use --root=ROOT or --root= to proceed anyway');
	''
}

# forget settings in /run/squashmount if $current_empty suggests to.

sub remove_settings {
	return '' unless (defined($current_empty));
	return '' unless (&hash_equal($current_empty, $current));
	my $file = &settings_file();
	(!(-f $file)) || unlink($file)
}

# Start locking in /run/squashmount unless $run_ro

sub start_locking {
	return unless ($locking && !$run_ro);
	my $file = &settings_file();
	unless (open($lockfh, '>>', $file)) {
		$lockfh = undef;
		return
	}
	flock($lockfh, Fcntl::LOCK_EX());
}

# End locking in /run/squashmount. Return 1 if we had a lock

sub end_locking {
	return '' unless (defined($lockfh));
	flock($lockfh, Fcntl::LOCK_UN());
	close($lockfh);
	$lockfh = undef;
	1
}

# Forget settings from $current and remember new state in $current_empty

sub forget_settings {
	&info('forgetting settings') unless ($quiet);
	$rm_rundir_on_end = 1;
	$current = {};
	&fill_current();
	&set_globals();
	$current_empty = {};
	%$current_empty = %$current
}

# Return the filename in /run/squashmount for the current tag

sub settings_file {
	File::Spec->catfile($rundir, ($_[0] // $tag))
}

# Fill "global" variables according to options and $current state

sub set_globals {
	$backup = ($opt_backup // $current->{'BACKUP'});
	$tempdir = ($opt_tempdir // $current->{'TEMPDIR'});
	$compression = ($opt_compression // $current->{'COMPRESSION'});
	$threshold = (($opt_threshold ne '') ?
		&parse_threshold($opt_threshold) : $current->{'THRESHOLD'});
	if (($threshold < 0) && ($threshold != -2)) {
		$kill = 0
	} else {
		$kill = ($opt_kill // &parse_kill($current->{'KILL'}))
	}
	$current_lazy = ($opt_lazy // $user_config->{'LAZY'}) // $lazy;
	$current_lsof = ($opt_lsof // $user_config->{'LSOF'}) // $lsof;
	$current_lsof_ro = ($opt_lsof_ro // $user_config->{'LSOF_RO'})
		// $lsof_ro
}

# Fill $current state with defaults from $user_config.

sub fill_current {
	my $force = (shift() // '');
	if ($force || !exists($current->{'BACKUP'})) {
		$current->{'BACKUP'} = $user_config->{'BACKUP'}
	}
	if ($force || !exists($current->{'TEMPDIR'})) {
		$current->{'TEMPDIR'} = $user_config->{'TEMPDIR'}
	}
	if ($force || !exists($current->{'COMPRESSION'})) {
		$current->{'COMPRESSION'} = $user_config->{'COMPRESSION'}
	}
	if ($force || !exists($current->{'THRESHOLD'})) {
		$current->{'THRESHOLD'} = &parse_threshold($user_config->{'THRESHOLD'})
	}
	if ($force || !exists($current->{'KILL'})) {
		$current->{'KILL'} = $user_config->{'KILL'}
	}
	1
}

# Turn argument into a number.

sub parse_threshold {
	my ($threshold) = @_;
	return 0 unless (defined($threshold));
	$threshold =~ s{[[:space:]]}{}gm;
	$threshold =~ s{^\+}{};
	return 0 unless ($threshold =~ m{^(\-?\d+)([kmgt])?$}i);
	use bigint;
	my ($num, $ext) = ($1, $2);
	return (-2) if (($num == -2) && !&is_nonempty($ext));
	return (-1) if ($num < 0);
	return $num unless (&is_nonempty($ext));
	for my $i (qr{k}i, qr{m}i, qr{g}i) {
		$num *= 1024;
		return $num if ($ext =~ $i)
	}
	$num * 1024  # if ($ext =~ m{t}i)
}

# Turn argument into a number.

sub parse_kill {
	my ($kill) = @_;
	return 0 unless (&is_nonempty($kill));
	return 1 unless (&is_integer($kill));
	return 0 if ($kill == 0);
	(($kill > 0) ? 1 : -1)
}

# Turn argument into a human-readable string

sub human_threshold {
	use bigint;
	my ($threshold) = @_;
	my $append = '';
	for my $i ('k', 'm', 'g', 't') {
		return "$threshold$append" if ($threshold < 512);
		$threshold = &roundup($threshold, 1024);
		$append = $i
	}
	"$threshold$append"
}

# Return $a / $b rounded up

sub roundup {
	use bigint;
	my ($a, $b) = @_;
	(($a + $b - 1) / $b)
}

# Check whether passed configuration has a directory from $pass_dir

sub find_pass_dir {
	my ($hash, $pass_dir) = @_;
	for my $i (
		$hash->{'DIR'},
		$hash->{'CHANGES'},
		$hash->{'WORKDIR'},
		$hash->{'READONLY'}) {
		return 1 if (exists($pass_dir->{$i}))
	}
	''
}

# Initialize and create $current->{$i} from $user_config->{$i} if necessary
# Returns 1 on success -1 if directory is a nonempty non-path, '' otherwise

sub create_dir {
	my ($i, $require_dir) = @_;
	if (exists($current->{$i})) {
		my $dir = $current->{$i};
		return -1 unless (&is_abspath($dir));
		return 1 if (-d $dir);
		# $current->{$i} directory was removed (e.g. by the user).
		# Recreate it, possibly generating a new tempdir...
	}
	my $dir = &create_dirname($user_config->{$i});
	unless (&is_nonempty($dir)) {
		&error("failed to create $i");
		return ''
	}
	if (&is_abspath($dir)) {
		$current->{$i} = $dir;
		return 1
	}
	if ($require_dir) {
		&error("no absolute directory $i");
		return ''
	}
	$current->{$i} = 1;
	-1
}

# Fetch a filename from @CFG::mounts, creating the directory if necessary

sub create_dirname {
	my $temp = (shift() // '');
	if (ref($temp) eq 'CODE') {
		$temp = $temp->($tag)
	}
	if (ref($temp) eq 'File::Temp::Dir') {
		$temp->unlink_on_destroy('');
		$temp = $temp->dirname;
	} elsif ($temp eq '') {
		$temp = File::Temp::newdir(undef, CLEANUP => '');
		$temp = $temp->dirname;
	}
	return $temp unless (&is_abspath($temp));
	unless (-d $temp) {
		return undef unless &make_directory($temp);
	}
	&bad_abs_path($temp)
}

# Return whether CHANGES makes sense and is a directory.
# With $create_dir, create it if necessary.

sub is_valid_changes {
	my ($create_dir) = @_;
	my $result = &is_resquash_type();
	return 1 if ($result);
	return '' if ($result ne '');
	return '' unless (&is_abspath(&get_abspath('READONLY', $create_dir, '')));
	&is_abspath(&get_abspath('CHANGES', $create_dir, 1));
}


# Return whether WORKDIR makes sense and is a directory.
# With $create_dir, create it if necessary.

sub is_valid_workdir {
	my ($create_dir) = @_;
	my $result = &is_workdir_type();
	return 1 if ($result);
	return '' if ($result ne '');
	return '' unless (&is_valid_changes($create_dir));
	&is_abspath(&get_abspath('WORKDIR', $create_dir, 1));
}


# Return absolute path from $current or $user_config.
# With $create_dir and $required_dir call &create_dir(..., $required_dir).
# With $create_dir only take resolved path to $user_config if possible.

sub get_abspath {
	my $i = shift();
	my $create_dir = (shift() // '');
	my ($required_dir) = @_;
	&create_dir($i, $required_dir) if ($create_dir && defined($required_dir));
	my $ret = $current->{$i};
	return $ret if (defined($ret));
	$ret = $user_config->{$i};
	return '' unless (defined($ret) || (ref($ret) ne ''));
	$ret = &good_abs_path($ret) if (&is_abspath($ret));
	$current->{$i} = $ret if ($create_dir);
	$ret
}

# Test if type is valid type for resquashing.
# Result is 1 (yes) or 0 (no) or the empty string if type is not known

sub is_resquash_type {
	my $type = $current->{'TYPE'};
	return '' unless (&is_nonempty($type));
	(($type eq 'readonly') || ($type =~ m{bind})) ? 0 : 1
}

# Test if type needs a WORKDIR.
# Result is 1 (yes) or 0 (no) or the empty string if it is not known

sub is_workdir_type {
	my $type = $current->{'TYPE'};
	return '' unless (&is_nonempty($type));
	return 1 if ($type eq 'overlay');
	(($type eq 'overlayfs') &&
		(($CFG::obsolete_overlayfs // '') ne 'force')) ? 1 : 0
}

# Test if DIR has valid type for fusermount; optionally take TYPE as arg.
# Return undef if not known

sub is_fuse_type {
	my $type  = (@_ ? $_[0] : $current->{'TYPE'});
	return undef unless (&is_nonempty($type));
	(($type eq 'fuse-overlayfs') || ($type eq 'unionfs-fuse') || ($type eq 'funionfs'))
}

# Test if READONLY has valid type for fusermount;
# optionally take MOUNT_RO  as arg.
# Return undef if not known

sub is_squashfuse_type {
	my $squashtype  = (@_ ? $_[0] : $current->{'MOUNT_RO'});
	return undef unless (&is_nonempty($squashtype) &&
		($squashtype ne 'unknown'));
	($squashtype eq 'squashfuse')
}

# Check whether dir is empty. Returns 1 or '', or 0 in case of error

sub dir_is_empty {
	my ($dir) = @_;
	my $dh = undef;
	return 0 unless (opendir($dh, $dir));
	while () {
		my $curr = readdir($dh);
		unless (defined($curr)) {
			closedir($dh);
			return 1
		}
		if (scalar(File::Spec->no_upwards(($curr)))) {
			closedir($dh);
			return ''
		}
	}
}

# Check whether CHANGES tree is empty or is more than $to_find long.
# Return value:
# '' dir does not exit
# 0 dir is empty
# 1 $to_find is reached
# -1 nonempty, but $to_find not reached

sub threshold_dir {
	my ($to_find) = @_;
	my $dir = &get_abspath('CHANGES');
	return '' unless (-d $dir);
	my ($dirv, @dir) = &split_dir($dir);
	&shift_empty(\@dir);
	my ($readonlyv, @readonly) = &split_dir(&get_abspath('READONLY'));
	my $found = '';  # Flag whether there is at least some data
	my $blocksize = undef;
	my $diskspace = sub {
		use bigint;
		my $size = shift();
		unless (defined($blocksize)) {
			my $bs = $user_config->{'BLOCKSIZE'};
			$blocksize = ((defined($bs) && ($bs > 0)) ? $bs : 4096 );
		}
		return $blocksize unless ($size);
		my $modulo = ($size % $blocksize);
		$modulo ? (($blocksize - $modulo) + $size) : $size
	};
	my $skipfunc = $user_config->{'SKIPFUNC'};
	my $skip = $user_config->{'SKIP'};
	my $skipdir = $user_config->{'SKIPDIR'};
	my $check = $user_config->{'DIFF'};
	my $fill = $user_config->{'FILL'};
	my $fillfunc = $user_config->{'FILLFUNC'};

	# Now some hidden files/directories for special filesystems:
	# We skip these files also if the $type does not match;
	# otherwise there would be confusion if e.g. changing from
	# aufs to overlay and thus suddenly aufs-hidden files are visible.
	# However, more exact would be to use the if-clauses of the comments:
	# my $type = $current->{'TYPE'};
	push(@$skip, qr{^\._funionfs});   # if ($type eq 'funionfs');
	push(@$skipdir, qr{^\.unionfs});  # if ($type =~ m{^unionfs});
	push(@$skip, qr{^\.wh\.\.wh\.aufs$}) &&
		push(@$skipdir, qr{^\.wh\.\.wh\.(pli?nk|\.tmp|orph)}n);
		# if ($type eq 'aufs');

	my @compare = ();  # postponed file content comparison...
	no warnings 'File::Find';
	File::Find::find({
		no_chdir => 1,
		follow => '',
		follow_fast => '',
		follow_skip => 2,
		dangling_symlinks => '',
		wanted => sub {
		if ($to_find < 0) {
			# Shortcut possible
			$File::Find::prune = 1;
			return
		}
		my ($pathv, @path) = &split_dir($_);
		&shift_empty(\@path);
		splice(@path, 0, scalar(@dir)) if (($pathv eq $dirv) &&
			&starts_with(\@path, \@dir));
		my $path = &cat_dir($pathv, @path);
		return if ((!@path) || &is_match($path, $skip));
		if (&is_match($path, $skipdir) && (-d $_) && !(-l $_)) {
			$File::Find::prune = 1;
			return
		}
		my $readonlysub = &cat_dir($readonlyv, @readonly, @path);
		if (&is_match($path, $check)) {
			return if &file_is_equal($_, $readonlysub, \@compare)
		}
		if (defined($skipfunc) && (ref($skipfunc) eq 'CODE')) {
			local $_;
			return unless ($skipfunc->($path, $_, $readonlysub))
		}
		my $currfill = &is_match($path, $fill);
		if ((!$currfill) && defined($fillfunc) && (ref($fillfunc) eq 'CODE')) {
			local $_;
			$currfill = $fillfunc->($path, $_, $readonlysub)
		}
		$found = 1;
		if ($currfill) {
			use bigint;
			$to_find = -1
		} else {
			use bigint;
			$to_find -= $diskspace->(((-l $_) || !(-f $_))
				? 1 : (-s $_));
		}
		$File::Find::prune = 1 if ($to_find < 0)
	}}, $dir);
	return 1 if ($to_find < 0);
	return ($found ? -1 : 0) unless (@compare);
	# We postponed comparing of files, because this takes time.
	# Only if $to_find is not yet reached but might be (due to @compare)
	# or if $found is not yet clear, we really do the comparison.
	# As a preprocessing, we honour BLOCKSIZE in the sizes of @compare and
	# calculate the maximal size of the files potentially in @compare:
	my $maximal_rest;
	{
		use bigint;
		$maximal_rest = 0;
		# >=perl-5.8.6 optimizes this loop without an auxiliary array:
		for my $i (reverse @compare) {
			$maximal_rest += ($i->[2] = $diskspace->($i->[2]))
		}
	}
	# Now we actually compare, keeping $maximal_rest up-to-date:
	for my $i (@compare) {
		{
			use bigint;
			if ($found && ($maximal_rest <= $to_find)) {
				no bigint;
				return -1
			}
			$maximal_rest -= $i->[2]
		}
		if (File::Compare::compare($i->[0], $i->[1])) {
			$found = 1;
			use bigint;
			$to_find -= $i->[2];
			if ($to_find < 0) {
				no bigint;
				return 1
			}
		}
	}
	$found ? -1 : 0
}

# subfunction of threshold_dir: Check whether filetypes are equal.
# For files, postpone content comparison by pushing [ $a, $b, $filesize]
# to @$compare.

sub file_is_equal {
	my ($a, $b, $compare) = @_;
	if (-l $a) {
		return (-l $b);
	}
	return '' if (-l $b);
	if (-d $a) {
		return (-d $b)
	}
	if (-f $a) {
		if (-f $b) {
			{
				use bigint;
				my $size = (-s $a);
				return '' if ($size ne (-s $b));
				push(@$compare, [ $a, $b, $size ])
			}
			return 1
		}
		return ''
	}
	!(-f $b)
}

# Compare against an array of regular expressions

sub is_match {
	my($a, $reg) = @_;
	for my $r (@$reg) {
		return 1 if ($a =~ $r)
	}
	''
}

# Make a directory with parents

sub make_directory {
	my ($dir) = @_;
	File::Path::make_path($dir, { error => \my $err });
	&filepath_ok($err, 1)
}

# Clean all files from a directory

sub clean_directory {
	my ($dir) = @_;
	if ($interactive) {
		print("Clean $dir? ");
		unless (<STDIN> =~ m{^y}i) {
			&info("keeping $dir") if ($verbose);
			return 1
		}
	}
	&info("cleaning $dir") if ($verbose);
	File::Path::remove_tree($dir, {
		keep_root => 1,
		error => \my $err
	});
	&filepath_ok($err, '')
}

# Handle the error of File::Path::make_path or File::Path::remove_tree.
# Return true if no error

sub filepath_ok {
	my ($err, $make_path) = @_;
	return 1 unless (@$err);
	my $text = $make_path ? 'creating' : 'removing';
	for my $diag (@$err) {
		my ($file, $message) = %$diag;
		if ($file eq '') {
			&error("(while $text): $message")
		} else {
			&error("(while $text $file): $message")
		}
	}
	''
}

# Output fatal error and die:

sub fatal {
	&output(\@_, 1, 'red', 'fatal: ', 1);
	exit(1)
}

# Output errors:

sub error {
	&output(\@_, 1, 'red', 'error:   ')
}

# Output errors without specifying "error"

sub errorinfo {
	&output(\@_, 1, 'red')
}

# Output warnings:

sub warning {
	&output(\@_, 1, 'yellow', 'warning: ')
}

# Output informal messages:

sub info {
	&output(\@_, 1, 'green')
}

# Main action of fatal, error, warning, info:

sub output {
	my ($array, $to_stderr, $colorname, $label, $notag) = @_;
	$label //= '';
	my $col = '';
	my $reset = '';
	if (($opt_color // ($to_stderr ?
		($stderrterm //= ((-t STDERR) // '')) : $stdoutterm))
		&& &use_ansicolor()) {
		state (%colorhash, $resethash);
		$col = ($colorhash{$colorname} //= Term::ANSIColor::color($colorname));
		$reset = ($resethash //= Term::ANSIColor::color('reset'))
	}
	my $first = '';
	my $len = length($label);
	if ($star) {
		$len += 3;
		$first = ' ' . $col . '*' . $reset . ' '
	}
	if (&is_nonempty($notag) || ($tag eq '')) {
		$len += length($name) + 2;
		$first .= $col . $name . $reset . ': '
	} else {
		$len += $taglen + 4;
		$first .= '[' . $col . $tag . $reset . ']: '
			. (' ' x ($taglen - length($tag)))
	}
	$first .= $label . $array->[0] . "\n";
	my @copy = @$array;
	my $s = (' ' x $len);
	grep($_ = "$s$_\n", @copy);
	$copy[0] = $first;
	if ($to_stderr) {
		print(STDERR @copy)
	} else {
		print(@copy)
	}
}

# Set title:

sub title {
	return unless (defined($titleopt) && &which_store(\$title, 'title'));
	my ($a) = @_;
	my @opt = ();
	push(@opt, "\-$titleopt") if ($titleopt ne '');
	if (system($title, @opt, '--', $a) == 0) {
		$printed_title = 1;
		return
	}
	# Apparently title is not available or does something else...
	$printed_title = '';
	$titleopt = undef
}

# If title was called once or we locked, we have to reset this on every exit:

END {
	&end_locking();
	&title(($? == 0) ? "$name finished" : "$name failed")
		if ($printed_title // '')
}

# Output of print-..., returning '' if undefined

sub do_print {
	my ($a) = @_;
	my $ret = 1;
	unless (defined($a)) {
		$ret = $a = '';
		$a = '(undefined)' unless ($quiet)
	}
	if ($quiet) {
		print($a . $separator);
		return $ret
	}
	if ($ret) {
		&info($a);
		return 1
	}
	&errorinfo($a);
	$ret
}

# Output of status-array

sub print_status {
	my ($a) = @_;
	if ($verbose) {
		&info(@$a)
	} else {
		&info(join(', ', @$a))
	}
}

# Call to which_store() (with optionally an array for second arg),
# followed by system(). Print error if tool not found.
# The first argument is special:
# '' or 0: Default mode
# 1: suppress stdout
# 2: suppress stdout and stderr

sub my_system {
	my $redirect = shift();
	my $a = shift();
	my $b = shift();
	$b = [ $b ] unless (ref($b) eq 'ARRAY');
	unless (&which_store($a, @$b)) {
		&error(join(', ', @$b) . ' not found in $PATH');
		return -1
	}
	&my_system_cmd($redirect, $$a, @_)
}

# Calls system() with appropriate messages
# The first argument is special:
# '' or 0: Default mode
# 1: suppress stdout
# 2: suppress stdout and stderr
sub my_system_cmd {
	my $redirect = shift();
	if ($verbose > 2) {
		print((@_ > 1) ? &shell_quote_best_effort(@_) : @_, "\n");
		$redirect = ''
	}
	my $oldout = undef;
	my $olderr = undef;
	if ($redirect) {
		if ($redirect > 1) {
			$olderr = undef unless (open($olderr, '>&', \*STDERR) && open(STDERR, '>', $devnull))
		}
		$oldout = undef unless (open($oldout, '>&', \*STDOUT) && open(STDOUT, '>', $devnull))
	}
	my $ret = system(@_);
	open(STDERR, '>&', $olderr) if (defined($olderr));
	open(STDOUT, '>&', $oldout) if (defined($oldout));
	($ret >= 0) ? ($ret >> 8) : $ret
}

# Store in the first argument the first successful "which" of the later args.
# Return 1 if some found.

sub which_store {
	my $a = shift();
	return ($$a ne '') if (defined($$a));
	for my $i (@_) {
		$$a = &my_which($i);
		return 1 if (($$a // '') ne '')
	}
	$$a = ''
}

# Act like which() with a fallback to `which ...`; if neither is available,
# returns the argument as "path". Must be used in scalar context.

sub my_which {
	my ($command) = @_;
	my $which = &which_which();
	return File::Which::which($command) if ($which eq ':');
	return $command if ($which eq '');
	my $olderr;
	$olderr = undef unless (open($olderr, '>&', \*STDERR) && open(STDERR, '>', $devnull));
	my $ret = `$which $command`;
	open(STDERR, '>&', $olderr) if (defined($olderr));
	chomp($ret) if (defined($ret));
	$ret
}

# use File::Which module and return ':'
# As a fallback a path to "which" or the empty string is returned

sub which_which {
	state $which;
	return $which if (defined($which));
	eval {
		require File::Which
	};
	return ($which = ':') unless ($@);
	my $olderr;
	$olderr = undef unless (open($olderr, '>&', \*STDERR) && open(STDERR, '>', $devnull));
	$which = `which which`;
	open(STDERR, '>&', $olderr) if (defined($olderr));
	return ($which = '') unless (defined($which));
	chomp($which);
	$which
}

# use Term::ANSIColor and return whether successful

sub use_ansicolor {
	state $ansicolor;
	return $ansicolor if (defined($ansicolor));
	eval {
		require Term::ANSIColor
	};
	$ansicolor = !$@
}

# Is argument empty or an integer?

sub is_integer {
	(shift() // '') =~ /^[+-]?\d*$/
}

# Is argument defined and nonempty?

sub is_nonempty {
	my $a = (shift() // '');
	((ref($a) eq '') && ($a ne ''))
}

# Is argument defined and an absolute path?

sub is_abspath {
	my ($arg) = @_;
	&is_nonempty($arg) && (File::Spec->file_name_is_absolute($arg))
}

# compare two hashes

sub hash_equal {
	my ($a, $b) = @_;
	for my $i (keys(%$a)) {
		next unless (defined($a->{$i}));
		return '' unless (defined($b->{$i}));
		return '' unless ($a->{$i} eq $b->{$i})
	}
	for my $i (keys(%$b)) {
		next unless (defined($b->{$i}));
		return '' unless (exists($a->{$i}))
	}
	1
}

# whether first array starts with the second array

sub starts_with {
	my ($a, $b, $numeric) = @_;
	return '' if (@$b > @$a);
	while(my ($i, $j) = each(@$b)) {
		if ($numeric ? ($a->[$i] != $j) : ($a->[$i] ne $j)) {
			keys(@$b);  # reset "each" counter
			return ''
		}
	}
	1
}

# If the first string in an array is empty, shift it

sub shift_empty {
	my ($a) = @_;
	(@$a && ($a->[0] eq '')) && shift(@$a)
}

# push string or reference to array of strings. If $s is undefined use $t

sub push_ref {
	my ($arr, $s, $t) = @_;
	$s = $t unless (defined($s));
	return unless (defined($s));
	if (ref($s) eq 'ARRAY') {
		push(@$arr, @$s);
		return
	}
	push(@$arr, $s) if ($s ne '')
}

# use String::ShellQuote () and return whether successful

sub use_shellquote {
	state $shellquote;
	return $shellquote if (defined($shellquote));
	eval {
		require String::ShellQuote
	};
	$shellquote = !$@
}

# like join(' ', @_), but shell-quote arguments

sub join_quoted {
	my @r;
	for my $i (@_) {
		my $a = $i;
		$a =~ s{\'}{\'\\\'\'}g;
		$a = "'$a'";
		$a =~ s{(\A|[^\\])\'([\w\-\,\.\:\/]*)\'}{$1$2}gm;
		push(@r, ($a ne '') ? $a : "''")
	}
	join(' ', @r)
}

sub shell_quote_best_effort {
	(&use_shellquote() ?
		&String::ShellQuote::shell_quote_best_effort : &join_quoted)
}

# Run hook functions from the configuration file:

sub run_hook {
	my ($value, $var) = @_;
	return 1 unless (defined($value));
	# Make a copy for arrays to allow callback functions modifiying array
	for my $i ((ref($value) eq 'ARRAY') ? @$value : ($value)) {
		if (ref($i) eq 'CODE') {
			return '' unless ($i->($tag, $current, $user_config))
		} else {
			&warning("callback variable $var is not a function/array of functions")
		}
	}
	1
}

# set $had_error and $exitstatus according to $errorbreak and $fatalreturn

sub bad_status {
	$had_error = 1 if ($errorbreak);
	$exitstatus = 1 unless ($fatalreturn || ($exitstatus != 0))
}

sub local_mtime {
	my $file = shift();
	return undef unless (&is_nonempty($file));
	my $mtime = (stat($file))[9];
	return undef unless (&is_nonempty($mtime));
	localtime($mtime)
}

# check whether argument is a nonempty string and the corresponding file exists

sub file_exists {
	my ($f) = @_;
	defined($f) && (ref(\$f) eq 'SCALAR') && ($f ne '') && (-e $f)
}

# If path is relative, make it absolute. Return true if result is_abspath

sub absolutify_path {
	my ($r) = @_;
	return '' unless (&is_nonempty($$r));
	my $f = File::Spec->canonpath($$r);
	return '' unless (&is_nonempty($f));
	unless (&is_abspath($f)) {
		$f = &good_abs_path($$r);
		return '' unless (&is_abspath($f))
	}
	$$r = $f;
	1
}

# abs_path('DIR/subdir/file') returns undef() if subdir does not exist in DIR.
# &good_abs_path() is abs_path() with this "bug" being fixed:
# It always returns a valid path. (Assumption: argument &is_abspath())

sub good_abs_path {
	my ($f) = @_;
	my $r = &bad_abs_path($f);
	return $r if (defined($r));
	my ($vol, @head) = &split_dir($f);
	my @tail = ();
	while(@head) {
		unshift(@tail, pop(@head));
		$r = &bad_abs_path(&cat_dir($vol, @head));
		if (defined($r)) {
			($vol, @head) = &split_dir($r);
			last
		}
	}
	&cat_dir($vol, @head, @tail)
}

# bad_abs_path() acts like abs_path but returns a normalized filename

sub bad_abs_path {
	my ($f) = @_;
	return undef unless (&is_nonempty($f));
	$f = Cwd::abs_path($f);
	return undef unless (&is_nonempty($f));
	$f = File::Spec->canonpath($f);
	&is_abspath($f) ? $f : undef
}

# split dir into volume and directory components

sub split_dir {
	my ($vol, $dir, $file) = File::Spec->splitpath(File::Spec->canonpath($_[0]));
	my @dir = File::Spec->splitdir($dir);
	pop(@dir) if (@dir && $dir[$#dir] eq '');
	push(@dir, $file) if ($file ne '');
	($vol, @dir)
}

# compose dir/file from volume and directory components

sub cat_dir {
	my $vol = shift();
	my $file = pop();
	File::Spec->catpath($vol, File::Spec->catdir(@_), $file)
}

sub rmdir_recurse {
	my ($dir, $parents) = @_;
	return 1 unless (($parents // '') && ($parents =~ m{^[+-]?\d+$}));
	while(-d $dir) {
		return 1 if (-l $dir);
		&info("trying to remove directory $dir") if ($verbose > 2);
		unless (rmdir($dir)) {
			&info("did not remove directory", "$!") if ($verbose > 2);
			return 1
		}
		if ($parents > 0) {
			return 1 if (--$parents)
		}
		my ($vol, @dirs) = &split_dir($dir);
		return 1 unless (@dirs);
		pop(@dirs);
		$dir = &cat_dir($vol, @dirs)
	}
	''
}

sub version {
	print($name, ' ', $VERSION, "\n");
	exit(0)
}

sub pod2usage {
	require Pod::Usage;
	&Pod::Usage::pod2usage
}

# Unfortunately, Getopt::Long::GetOptions cannot combine multiple args with
# short option bundling. So we must role our own...

sub get_options() {
	my %options = ();
	my $define_option = sub {
		my ($name, $action) = @_;
		if ($name eq '') {
			die 'empty option specified'
		}
		if (exists($options{$name})) {
			die "duplicate option specified: $name"
		}
		$options{$name} = $action
	};
	while (@_) {
		my $opt = shift();
		my $operand = shift();
		my $action = [ {}, $operand ];
		if ((ref($operand) ne 'SCALAR') && (ref($operand) ne 'CODE') &&
			ref($operand) ne 'ARRAY') {
			die 'no valid operand specified'
		}
		my $flags = $action->[0];
		my $negate = '';
		for (;;) {
			if ($opt =~ s{\{([^\{].*)\}$}{}) {
				$flags->{'repeat'} = $1;
				next
			}
			if ($opt =~ s{\=s$}{}) {
				$flags->{'arg'} = 1;
				next
			}
			if ($opt =~ s{\+$}{}) {
				$flags->{'count'} = 1;
				next
			}
			if ($opt =~ s{\!$}{}) {
				$negate = 1;
				next
			}
			last
		}
		my @opts = (split(/\|/, $opt));
		unless(@opts) {
			die 'no option specified'
		}
		for my $name (@opts) {
			$define_option->($name, $action);
		}
		next unless ($negate);
		$action = [ &added_hash($flags, { 'negate' => 1 }), $operand ];
		for my $name (@opts) {
			$define_option->('no' . $name, $action);
			$define_option->('no-' . $name, $action)
		}
	}
	for (my $i = 0; $i < @ARGV; ) {
		my $arg = $ARGV[$i];
		if ($arg eq '--') {
			splice(@ARGV, $i, 1);
			return 1
		}
		my $opt;
		my $optarg = undef;
		my $flags;
		my $operand;
		my $get_action = sub {
			if (!exists($options{$opt})) {
				print(STDERR "Unknown option: $opt\n");
				return ''
			}
			my $action = $options{$opt};
			$flags = $action->[0];
			$operand = $action->[1];
		};
		my $do_arg_action = sub {
			my $repeat = $flags->{'repeat'} // 0;
			my $add = $repeat || 1;
			--$add if (defined($optarg));
			if ($add) {
				if ($i + $add >= @ARGV) {
					print(STDERR (($repeat <= 1) ?
					"Option $opt requires an argument\n" :
					"Option $opt requires $repeat arguments\n"));
					return ''
				}
				if ($repeat) {
					$optarg = [
					((defined($optarg) ? $optarg : ()),
					splice(@ARGV, $i + 1, $add))
					];
				} else {
					$optarg = splice(@ARGV, $i + 1, 1)
				}
			}
			if (ref($operand) eq 'ARRAY') {
				push(@$operand, $optarg)
			} elsif (ref($operand) eq 'CODE') {
				$operand->($opt, $optarg)
			} else {
				$$operand = $optarg
			}
			1
		};
		my $do_action = sub {
			if ($flags->{'arg'}) {
				return $do_arg_action->();
			}
			if (ref($operand) eq 'CODE') {
				$operand->($opt);
			} elsif ($flags->{'count'} &&
				defined($$operand) && ($$operand ne '')) {
				if ($flags->{'negate'}) {
					--$$operand
				} else {
					++$$operand
				}
			} elsif ($flags->{'negate'}) {
				$$operand = ''
			} else {
				$$operand = 1
			}
			1
		};
		if ($arg =~ m{^\-\-([^=]+)(?:\=(.*))?$}) {
			$opt = $1;
			$optarg = $2 if (defined($2));
			return '' unless ($get_action->());
			if (defined($optarg) && !$flags->{'arg'}) {
				print(STDERR "Option $opt does not take an argument\n");
				return ''
			}
			return '' unless ($do_action->())
		} else {
			my $is_option = '';
			while ($arg =~ m{^-(.)(.*)$}) {
				$is_option = 1;
				$opt = $1;
				my $rest = $2;
				$optarg = $2 if ($2 ne '');
				return '' unless ($get_action->()
					&& $do_action->());
				last if ($flags->{'arg'});
				$arg = '-' . $rest;
			}
			unless ($is_option) {
				++$i;
				next
			}
		}
		splice(@ARGV, $i, 1)
	}
	1
}


#
# Now the main program:
#

# Parse Options:

&get_options(
	'help|h', sub { &pod2usage(0) },
	'man|?', sub { &pod2usage(-verbose => 2, -exit => 0) },
	'version|V', \&version,
	'config|c=s', \@configs,
	'system-config=s', \@system_configs,
	'umount|u=s', \@CFG::umount,
	'umount-ro|U=s', \@CFG::umount_ro,
	'fumount=s', \@CFG::fumount,
	'fumount-ro=s', \@CFG::fumount_ro,
	'order|o=s', \$opt_order,
	'squashorder|O=s', \$opt_squashorder,
	'allow!', \$opt_allow_other,
	'root|/=s', \$opt_root,
	'arg|a=s', \@argv,
	'bind|2=s{2}', \@bind,
	'rundir=s', \$rundir,
	'separator|S=s', \$separator,
	'interactice|i', \$interactive,
	'threshold|t=s', \$opt_threshold,
	'no-squash|nosquash|n', sub { $opt_threshold = '-1' },
	'squash|s', sub { $opt_threshold = '0' },
	'force-squash|squash-force', sub { $opt_threshold = '-2' },
	'kill-or-resquash|R', sub { $opt_kill = -1 },
	'kill|k', sub { $opt_kill = 1 },
	'no-kill|nokill|K', sub { $opt_kill = 0 },
	'tar2sqfs|tar', \$use_tar2sqfs,
	'no-tar2sqfs|notar2sqfs|no-tar|notar', sub { $use_tar2sqfs = '' },
	'compression|comp|x=s', \$opt_compression,
	'tempdir|D=s', \$opt_tempdir,
	'backup|b=s', \$opt_backup,
	'no-backup|nobackup|B', sub { $opt_backup = '' },
	'mksquash-verbose=s', \$mksquash_verbose,
	'processors|p=s', \$processors,
	'mem|m=s', \$mem,
	'lazy|L=s', \$opt_lazy,
	'lsof|l=s', \$opt_lsof,
	'lsof-ro=s', \$opt_lsof_ro,
	'll', \$squashfuse_ll,
	'locking!', \$locking,
	'force|f', \$force,
	'ignore-state|I', \$ignore_state,
	'reset|r', \$reset,
	'pass-dir', \$pass_dir,
	'title|T=s', \@title,
	'color|F', \$opt_color,
	'no-color|nocolor|C', sub { $opt_color = '' },
	'star!', \$star,
	'fatal!', \$fatalreturn,
	'error|e', \$errorbreak,
	'user', \$opt_user,
	'no-error|noerror|E', sub { $errorbreak = '' },
	'first|1', \$firstmatch,
	'verbose|v+', \$verbose,
	'quiet|q+', \$quiet
) or &pod2usage(2);

# Check and postprocess options:

&fatal('--lazy=' . $opt_lazy . ' is non-integer')
	if (defined($opt_lazy) && !&is_integer($opt_lazy));
&fatal('--lsof=' . $opt_lsof . ' is non-integer')
	if (defined($opt_lsof) && !&is_integer($opt_lsof));
&fatal('--lsof-ro=' . $opt_lsof_ro . ' is non-integer')
	if (defined($opt_lsof_ro) && !&is_integer($opt_lsof_ro));
if ($opt_user) {
	@configs = (File::Spec->catfile($ENV{'HOME'} // $root, '.squashmount.pl'))
		unless (@configs);
	$rundir //= File::Spec->catdir($ENV{'TEMPDIR'} // $root, 'tmp',
		'squashmount' . $<)
} else {
	@configs = (File::Spec->catfile($root, 'etc', 'squashmount.pl'))
		unless (@configs);
	$rundir //= File::Spec->catdir($root, 'run', 'squashmount')
}
@system_configs = (File::Spec->catfile($root, 'usr', 'lib', 'squashmount.pl'),
	File::Spec->catfile($root, 'lib', 'squashmount.pl'))
	unless (@system_configs);
&fatal("--rundir argument $rundir is not an absolute path")
	unless (&absolutify_path(\$rundir));
for my $i (@configs, @system_configs) {
	&fatal("config-file $i is not an absolute path")
		unless (&absolutify_path(\$i))
}
if (defined($opt_root)) {
	if ($opt_root ne '') {
		&fatal("--root argument $opt_root is not an accessible directory")
			unless((-d $opt_root) &&
				&calculate_inode($opt_root, \$rootdata))
	} else {
		$rootdata = ''
	}
}
for my $i (@bind) {
	for (my $j = 0; $j < 2; ++$j) {
		my $p = $i->[$j];
		&fatal("--bind argument $p is not an absolute path")
			unless(&absolutify_path(\$p));
		$i->[$j] = [ (&split_dir($p)) ]
	}
}
if (defined($opt_allow_other)) {
	@allow_other = () unless ($opt_allow_other)
} elsif ($opt_user) {
	@allow_other = ()
}

if ($quiet < $verbose) {
	$verbose -= $quiet; $quiet = 0
} else {
	$quiet -= $verbose; $verbose = 0
}
$titleopt = join('', @title);
undef(@title);
$titleopt = undef if (($titleopt =~ m{-}) || !$stdoutterm);

# Determine $action, $fatalreturn, $run_ro, $star, $CFG::locking,
# @CFG::order, @CFG::squashorder

my $action = (shift(@ARGV) // '');
{
	my $order_needed = '';
	my $cmd = undef;
	$run_ro = '';
	if ($action =~ m{^p}i) {
		$run_ro = 1;
		if ($action =~ m{tag}i) {
			$cmd = 'print-tag';
			$action = \&cmd_print_tag
		} elsif ($action =~ m{dir}i) {
			$cmd = 'print-dir';
			$action = \&cmd_print_dir
		} elsif ($action =~ m{chan}i) {
			$cmd = 'print-changes';
			$action = \&cmd_print_changes
		} elsif ($action =~ m{wor}i) {
			$cmd = 'print-workdir';
			$action = \&cmd_print_workdir
		} elsif ($action =~ m{read|ro}i) {
			$cmd = 'print-readonly';
			$action = \&cmd_print_readonly
		} elsif ($action =~ m{fil}i) {
			$cmd = 'print-file';
			$action = \&cmd_print_file
		} elsif ($action =~ m{tim}i) {
			$cmd = 'print-mtime';
			$action = \&cmd_print_mtime
		} elsif ($action =~ m{s.*typ}i) {
			$cmd = 'print-squashtype';
			$action = \&cmd_print_squashtype
		} elsif ($action =~ m{typ}i) {
			$cmd = 'print-type';
			$action = \&cmd_print_type
		} elsif ($action =~ m{new|mod}i) {
			$cmd = 'print-new';
			$action = \&cmd_print_new
		} elsif ($action =~ m{will|sq|comp}i) {
			$cmd = 'print-will_squash';
			$action = \&cmd_print_will_squash
		} elsif ($action =~ m{thr}i) {
			$cmd = 'print-threashold';
			$action = \&cmd_print_threshold
		} elsif ($action =~ m{kil}i) {
			$cmd = 'print-kill';
			$action = \&cmd_print_kill
		}
	} elsif ($action =~ m{^(stat|l)}ni) {
		$cmd = 'status';
		$run_ro = 1;
		$action = \&cmd_status
	} elsif ($action =~ m{^mo}i) {
		$cmd = 'mount';
		$order_needed = 1;
		$action = \&cmd_mount
	} elsif ($action =~ m{^star}i) {
		$cmd = 'start';
		$order_needed = 1;
		$fatalreturn = 1 unless (defined($fatalreturn));
		$action = \&cmd_start
	} elsif ($action =~ m{^cr}i) {
		$cmd = 'create';
		$action = \&cmd_create
	} elsif ($action =~ m{^ch}i) {
		$cmd = 'check';
		$run_ro = 1;
		$opt_lazy = '' unless (defined($opt_lazy));
		$opt_lsof = 1 unless (defined($opt_lsof));
		$opt_lsof_ro = 1 unless (defined($opt_lsof_ro));
		$action = \&cmd_check
	} elsif ($action =~ m{set}i) {
		if ($action =~ m{[ur]}i) {
			$cmd = 'reset';
			$action = \&cmd_reset
		} else {
			$cmd = 'set';
			$action = \&cmd_set
		}
	} elsif ($action =~ m{^u}i) {
		$cmd = 'umount';
		$action = \&cmd_umount
	} elsif ($action =~ m{^sto}i) {
		$cmd = 'stop';
		$fatalreturn = 1 unless (defined($fatalreturn));
		$action = \&cmd_stop
	} elsif ($action =~ m{^rem}i) {
		$cmd = 'remount';
		$order_needed = 1;
		$action = \&cmd_remount
	} elsif ($action =~ m{^rest}i) {
		$cmd = 'restart';
		$fatalreturn = 1 unless (defined($fatalreturn));
		$order_needed = 1;
		$action = \&cmd_restart
	} elsif ($action =~ m{^for}i) {
		$cmd = 'forget';
		$action = \&cmd_forget
	} elsif ($action =~ m{^m}i) {
		# $cmd = 'man';
		&pod2usage(-verbose => 2, -exit => 0)
	} elsif ($action =~ m{^[h\?]}i) {
		# $cmd = 'help';
		&pod2usage(0)
	}
	&pod2usage(2) unless (ref($action) eq 'CODE');
	$fatalreturn = '' unless (defined($fatalreturn));
	$star = 1  # !$run_ro  # Use this to make --no-star the default for infos
		unless (defined($star));
	$run_ro = '' if ($force || $ignore_state);
	$CFG::storing = $CFG::locking = !$run_ro;
	if ($order_needed) {
		if ($opt_user) {
			@CFG::order = qw(fuse-overlayfs!! unionfs-fuse!! funionfs!!);
			@CFG::squashorder = qw(squashfuse!!)
		} else {
			@CFG::order = qw(overlay!? overlayfs!? aufs! fuse-overlayfs! unionfs-fuse! unionfs! funionfs!);
			@CFG::squashorder = qw(squashfs!? squashfuse!)
		}
	}

	&fatal('internal error: undefined $cmd. Please report a bug')
		unless (defined($cmd));
	$CFG::command = $cmd
}

# Immadiate output without caching:

$|=1;

# Read config files:

{
	local @ARGV = @argv;
	my $have_read_config = '';
	for my $file (@configs) {
		$have_read_config = 1 if (&read_config_file($file))
	}
	unless ($have_read_config) {
		for my $file (@system_configs) {
			if (&read_config_file($file)) {
				$have_read_config = 1;
				last
			}
		}
	}
	$run_ro = !$CFG::storing;
	fatal('None of the config files could be read:',
		@configs, @system_configs) unless ($have_read_config)
}

# Modify options according to config:

$lazy = $CFG::lazy;
$lsof = $CFG::lsof;
$lsof_ro = $CFG::lsof_ro;
$squashfuse_ll = $CFG::squashfuse_ll unless (defined($squashfuse_ll));
$locking = $CFG::locking unless (defined($locking));
$use_tar2sqfs = $CFG::tar2sqfs unless (defined($use_tar2sqfs));
$modprobe_loop = $CFG::modprobe_loop;
$resquash_on_start = $CFG::resquash_on_start;
$rm_rundir = $CFG::rm_rundir;
$rm_dir = $CFG::rm_dir;
$rm_changes = $CFG::rm_changes;
$rm_workdir = $CFG::rm_workdir;
$rm_readonly = $CFG::rm_readonly;
&fatal('Obsolete $squash_verbose is set in the configuration.',
'Do not define $squash_verbose; set $mksquash_verbose instead.')
	if (defined($CFG::squash_verbose));
$mksquash_verbose = $CFG::mksquash_verbose unless (defined($mksquash_verbose));
$processors = $CFG::processors unless (defined($processors));
$processors = '' unless (defined($processors) && !($processors =~ m{^\s+$}));
$mem = $CFG::mem unless (defined($mem));
$mem = '' unless (defined($mem) && !($mem =~ m{^\s+$}));
if (defined($CFG::killpower)) {
	for my $i ((ref($CFG::killpower) eq 'ARRAY') ?
		@$CFG::killpower : ($CFG::killpower)) {
		if (&file_exists($i)) {
			&info('existing $killpower: ' . $i) unless ($quiet);
			$opt_threshold = '-1';
			last
		}
	}
}
@order = grep($_ ne '', (defined($opt_order) ?
	(split(/[^a-zA-Z\!\#\?\-]+/, $opt_order)) : @CFG::order));
@squashorder = grep($_ ne '', (defined($opt_squashorder) ?
	(split(/[^a-zA-Z\!\#\?\-]+/, $opt_squashorder)) : @CFG::squashorder));

# Fill the %tags array in the appropriate order.
# As a side result calculate $taglen.

my %tags = ();
$taglen = 0;
while(my ($i, $mountpoint) = each(@CFG::mounts)) {
	&fatal('config error: element ' . ($i + 1) . ' of @mounts is not a hash reference')
		unless (ref($mountpoint) eq 'HASH');
	my $tag = $mountpoint->{'TAG'};
	&fatal('config error: mount-point ' . ($i + 1) . ' has no TAG')
		unless (&is_nonempty($tag));
	&fatal("config error: \[$tag\]: tag not alphanumeric")
		if ($tag =~ m{[^\w\.\-]});
	&fatal("config error: \[$tag\]: tag duplicate in mount-points" .
		($tags{$tag} + 1) . ' and ' . ($i + 1)) if (exists($tags{$tag}));
	$tags{$tag} = $i;
	$taglen = length($tag) if (length($tag) > $taglen);
	&fatal("config error: \[$tag\]: no absolute FILE specified")
		unless (&is_abspath($mountpoint->{'FILE'}));
	my $dir = $mountpoint->{'DIR'};
	&fatal("config error: \[$tag\]: no absolute DIR specified")
		unless (defined($dir) && ((ref($dir) eq 'CODE')
			|| &is_abspath($dir)));
	# Compile all regular expressions and transform into arrays:
	for my $j ('SKIP', 'SKIPDIR', 'DIFF', 'FILL') {
		my $a = $mountpoint->{$j};
		unless (defined($a)) {
			$mountpoint->{$j} = [];
			next
		}
		if (ref($a) ne 'ARRAY') {
			if (ref($a) eq 'Regexp') {
				$mountpoint->{$j} = [ $a ]
			} elsif ((ref(\$a) eq 'SCALAR') && ($a ne '')) {
				$mountpoint->{$j} = [ qr{$a}nm ]
			} else {
				&fatal("config error: \[$tag\]: $j no Regexp or string")
			}
			next
		}
		for my $r (@$a) {
			next if (ref($r) eq 'Regexp');
			&fatal("config error: \[$tag\]: entry in $j no Regexp or string")
				unless ((ref(\$r) eq 'SCALAR') && ($r ne ''));
			$r = qr{$r}nm
		}
	}
}

# Now fill @mounts or %pass_dir, respectively, according to masks:

my @mounts = ();
my %pass_dir = ();

if ($pass_dir) {
	for my $i (@ARGV) {
		$pass_dir{$i} = 1 if (&is_abspath($i));
		my $j = &good_abs_path($i);
		$pass_dir{$j} = 1 if (&is_abspath($j))
	}
} else {
	if (@ARGV) {
		for my $i (@ARGV) {
			$i =~ s{([^\w\*\?\[\]])}{\\$1}g;
			$i =~ s{\*}{.*}g;
			$i =~ s{\?}{.}g;
			my $reg = qr{\A$i\z}nm;
			for my $j (@CFG::mounts) {
				next unless ($j->{'TAG'} =~ $reg);
				next if (exists($j->{'DONE'}));
				push(@mounts, $j);
				$j->{'DONE'} = 1
			}
		}
	} else {
		@mounts = @CFG::mounts
	}
	unless (@mounts) {
		&warning('no mount-points selected') unless ($quiet);
		exit(0)
	}
}

# Make sure that /run/squashmount exists (unless we have $run_ro)

&make_directory($rundir) unless ($run_ro || (-d $rundir));
$rm_rundir_on_end = '';

# Finally, the main loop over the @mounts or %pass_dir entries:

for my $i ($pass_dir ? (@CFG::mounts) : (@mounts)) {
	$user_config = $i;
	$tag = $i->{'TAG'};
	$current_empty = undef;
	&read_settings();
	unless (&validate_root()) {
		&bad_status();
		next
	}
	if ($pass_dir) {
		next unless (&find_pass_dir($current, \%pass_dir)
			|| &find_pass_dir($user_config, \%pass_dir))
	}
	&start_locking();
	my %current_bak = %$current;
	&fill_current();
	&set_globals();
	&bad_status() unless (&run_hook($CFG::before, '$before') &&
		$action->());
	if (&run_hook($CFG::after, '$after') && !$run_ro) {
		unless (&remove_settings() || &hash_equal(\%current_bak, $current)) {
			&bad_status() unless (&write_settings())
		}
	}
	&end_locking();
	last if ($firstmatch || $had_error)
}
&rmdir_recurse($rundir, $rm_rundir) if ($rm_rundir_on_end);
exit($exitstatus);

# Auxiliary functions which are convenient to have when debugging:

sub print_arr {
	print(join(' ', map("'$_'", @_)), "\n")
}
